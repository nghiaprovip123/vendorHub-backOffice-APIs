
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Tenant
 * 
 */
export type Tenant = $Result.DefaultSelection<Prisma.$TenantPayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Seller
 * 
 */
export type Seller = $Result.DefaultSelection<Prisma.$SellerPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model ServiceMedia
 * 
 */
export type ServiceMedia = $Result.DefaultSelection<Prisma.$ServiceMediaPayload>
/**
 * Model ServiceEvaluation
 * 
 */
export type ServiceEvaluation = $Result.DefaultSelection<Prisma.$ServiceEvaluationPayload>
/**
 * Model ServiceRating
 * 
 */
export type ServiceRating = $Result.DefaultSelection<Prisma.$ServiceRatingPayload>
/**
 * Model ServicePricingRule
 * 
 */
export type ServicePricingRule = $Result.DefaultSelection<Prisma.$ServicePricingRulePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const PricingType: {
  FIXED: 'FIXED',
  HIDDEN: 'HIDDEN',
  DYNAMIC: 'DYNAMIC',
  STAFF_TIERED: 'STAFF_TIERED',
  QUOTE_BASED: 'QUOTE_BASED'
};

export type PricingType = (typeof PricingType)[keyof typeof PricingType]

}

export type PricingType = $Enums.PricingType

export const PricingType: typeof $Enums.PricingType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Tenants
 * const tenants = await prisma.tenant.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Tenants
   * const tenants = await prisma.tenant.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.tenant`: Exposes CRUD operations for the **Tenant** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tenants
    * const tenants = await prisma.tenant.findMany()
    * ```
    */
  get tenant(): Prisma.TenantDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.seller`: Exposes CRUD operations for the **Seller** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sellers
    * const sellers = await prisma.seller.findMany()
    * ```
    */
  get seller(): Prisma.SellerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceMedia`: Exposes CRUD operations for the **ServiceMedia** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceMedias
    * const serviceMedias = await prisma.serviceMedia.findMany()
    * ```
    */
  get serviceMedia(): Prisma.ServiceMediaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceEvaluation`: Exposes CRUD operations for the **ServiceEvaluation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceEvaluations
    * const serviceEvaluations = await prisma.serviceEvaluation.findMany()
    * ```
    */
  get serviceEvaluation(): Prisma.ServiceEvaluationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceRating`: Exposes CRUD operations for the **ServiceRating** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceRatings
    * const serviceRatings = await prisma.serviceRating.findMany()
    * ```
    */
  get serviceRating(): Prisma.ServiceRatingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicePricingRule`: Exposes CRUD operations for the **ServicePricingRule** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePricingRules
    * const servicePricingRules = await prisma.servicePricingRule.findMany()
    * ```
    */
  get servicePricingRule(): Prisma.ServicePricingRuleDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.19.1
   * Query Engine version: c2990dca591cba766e3b7ef5d9e8a84796e47ab7
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Tenant: 'Tenant',
    User: 'User',
    Seller: 'Seller',
    Service: 'Service',
    ServiceMedia: 'ServiceMedia',
    ServiceEvaluation: 'ServiceEvaluation',
    ServiceRating: 'ServiceRating',
    ServicePricingRule: 'ServicePricingRule'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "tenant" | "user" | "seller" | "service" | "serviceMedia" | "serviceEvaluation" | "serviceRating" | "servicePricingRule"
      txIsolationLevel: never
    }
    model: {
      Tenant: {
        payload: Prisma.$TenantPayload<ExtArgs>
        fields: Prisma.TenantFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TenantFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TenantFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findFirst: {
            args: Prisma.TenantFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TenantFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          findMany: {
            args: Prisma.TenantFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>[]
          }
          create: {
            args: Prisma.TenantCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          createMany: {
            args: Prisma.TenantCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TenantDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          update: {
            args: Prisma.TenantUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          deleteMany: {
            args: Prisma.TenantDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TenantUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TenantUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TenantPayload>
          }
          aggregate: {
            args: Prisma.TenantAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTenant>
          }
          groupBy: {
            args: Prisma.TenantGroupByArgs<ExtArgs>
            result: $Utils.Optional<TenantGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.TenantFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.TenantAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.TenantCountArgs<ExtArgs>
            result: $Utils.Optional<TenantCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.UserFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.UserAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Seller: {
        payload: Prisma.$SellerPayload<ExtArgs>
        fields: Prisma.SellerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SellerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SellerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          findFirst: {
            args: Prisma.SellerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SellerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          findMany: {
            args: Prisma.SellerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>[]
          }
          create: {
            args: Prisma.SellerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          createMany: {
            args: Prisma.SellerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SellerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          update: {
            args: Prisma.SellerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          deleteMany: {
            args: Prisma.SellerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SellerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SellerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SellerPayload>
          }
          aggregate: {
            args: Prisma.SellerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSeller>
          }
          groupBy: {
            args: Prisma.SellerGroupByArgs<ExtArgs>
            result: $Utils.Optional<SellerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.SellerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.SellerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.SellerCountArgs<ExtArgs>
            result: $Utils.Optional<SellerCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      ServiceMedia: {
        payload: Prisma.$ServiceMediaPayload<ExtArgs>
        fields: Prisma.ServiceMediaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceMediaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceMediaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>
          }
          findFirst: {
            args: Prisma.ServiceMediaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceMediaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>
          }
          findMany: {
            args: Prisma.ServiceMediaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>[]
          }
          create: {
            args: Prisma.ServiceMediaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>
          }
          createMany: {
            args: Prisma.ServiceMediaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceMediaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>
          }
          update: {
            args: Prisma.ServiceMediaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>
          }
          deleteMany: {
            args: Prisma.ServiceMediaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceMediaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceMediaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceMediaPayload>
          }
          aggregate: {
            args: Prisma.ServiceMediaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceMedia>
          }
          groupBy: {
            args: Prisma.ServiceMediaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceMediaGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceMediaFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceMediaAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceMediaCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceMediaCountAggregateOutputType> | number
          }
        }
      }
      ServiceEvaluation: {
        payload: Prisma.$ServiceEvaluationPayload<ExtArgs>
        fields: Prisma.ServiceEvaluationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceEvaluationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceEvaluationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>
          }
          findFirst: {
            args: Prisma.ServiceEvaluationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceEvaluationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>
          }
          findMany: {
            args: Prisma.ServiceEvaluationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>[]
          }
          create: {
            args: Prisma.ServiceEvaluationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>
          }
          createMany: {
            args: Prisma.ServiceEvaluationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceEvaluationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>
          }
          update: {
            args: Prisma.ServiceEvaluationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>
          }
          deleteMany: {
            args: Prisma.ServiceEvaluationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceEvaluationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceEvaluationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceEvaluationPayload>
          }
          aggregate: {
            args: Prisma.ServiceEvaluationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceEvaluation>
          }
          groupBy: {
            args: Prisma.ServiceEvaluationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceEvaluationGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceEvaluationFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceEvaluationAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceEvaluationCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceEvaluationCountAggregateOutputType> | number
          }
        }
      }
      ServiceRating: {
        payload: Prisma.$ServiceRatingPayload<ExtArgs>
        fields: Prisma.ServiceRatingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceRatingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceRatingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          findFirst: {
            args: Prisma.ServiceRatingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceRatingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          findMany: {
            args: Prisma.ServiceRatingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>[]
          }
          create: {
            args: Prisma.ServiceRatingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          createMany: {
            args: Prisma.ServiceRatingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServiceRatingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          update: {
            args: Prisma.ServiceRatingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          deleteMany: {
            args: Prisma.ServiceRatingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceRatingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServiceRatingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceRatingPayload>
          }
          aggregate: {
            args: Prisma.ServiceRatingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceRating>
          }
          groupBy: {
            args: Prisma.ServiceRatingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceRatingGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServiceRatingFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServiceRatingAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServiceRatingCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceRatingCountAggregateOutputType> | number
          }
        }
      }
      ServicePricingRule: {
        payload: Prisma.$ServicePricingRulePayload<ExtArgs>
        fields: Prisma.ServicePricingRuleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePricingRuleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePricingRuleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>
          }
          findFirst: {
            args: Prisma.ServicePricingRuleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePricingRuleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>
          }
          findMany: {
            args: Prisma.ServicePricingRuleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>[]
          }
          create: {
            args: Prisma.ServicePricingRuleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>
          }
          createMany: {
            args: Prisma.ServicePricingRuleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ServicePricingRuleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>
          }
          update: {
            args: Prisma.ServicePricingRuleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>
          }
          deleteMany: {
            args: Prisma.ServicePricingRuleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePricingRuleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ServicePricingRuleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePricingRulePayload>
          }
          aggregate: {
            args: Prisma.ServicePricingRuleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePricingRule>
          }
          groupBy: {
            args: Prisma.ServicePricingRuleGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePricingRuleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.ServicePricingRuleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.ServicePricingRuleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.ServicePricingRuleCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePricingRuleCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    tenant?: TenantOmit
    user?: UserOmit
    seller?: SellerOmit
    service?: ServiceOmit
    serviceMedia?: ServiceMediaOmit
    serviceEvaluation?: ServiceEvaluationOmit
    serviceRating?: ServiceRatingOmit
    servicePricingRule?: ServicePricingRuleOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type TenantCountOutputType
   */

  export type TenantCountOutputType = {
    services: number
  }

  export type TenantCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | TenantCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TenantCountOutputType
     */
    select?: TenantCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TenantCountOutputType without action
   */
  export type TenantCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    services: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | UserCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type SellerCountOutputType
   */

  export type SellerCountOutputType = {
    services: number
  }

  export type SellerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | SellerCountOutputTypeCountServicesArgs
  }

  // Custom InputTypes
  /**
   * SellerCountOutputType without action
   */
  export type SellerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SellerCountOutputType
     */
    select?: SellerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SellerCountOutputType without action
   */
  export type SellerCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    pricingRules: number
    medias: number
    evaluation: number
    rating: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    pricingRules?: boolean | ServiceCountOutputTypeCountPricingRulesArgs
    medias?: boolean | ServiceCountOutputTypeCountMediasArgs
    evaluation?: boolean | ServiceCountOutputTypeCountEvaluationArgs
    rating?: boolean | ServiceCountOutputTypeCountRatingArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountPricingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePricingRuleWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountMediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceMediaWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountEvaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceEvaluationWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountRatingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRatingWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Tenant
   */

  export type AggregateTenant = {
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  export type TenantMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TenantCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TenantMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TenantCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TenantAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenant to aggregate.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Tenants
    **/
    _count?: true | TenantCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TenantMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TenantMaxAggregateInputType
  }

  export type GetTenantAggregateType<T extends TenantAggregateArgs> = {
        [P in keyof T & keyof AggregateTenant]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTenant[P]>
      : GetScalarType<T[P], AggregateTenant[P]>
  }




  export type TenantGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TenantWhereInput
    orderBy?: TenantOrderByWithAggregationInput | TenantOrderByWithAggregationInput[]
    by: TenantScalarFieldEnum[] | TenantScalarFieldEnum
    having?: TenantScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TenantCountAggregateInputType | true
    _min?: TenantMinAggregateInputType
    _max?: TenantMaxAggregateInputType
  }

  export type TenantGroupByOutputType = {
    id: string
    name: string
    slug: string
    createdAt: Date
    updatedAt: Date
    _count: TenantCountAggregateOutputType | null
    _min: TenantMinAggregateOutputType | null
    _max: TenantMaxAggregateOutputType | null
  }

  type GetTenantGroupByPayload<T extends TenantGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TenantGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TenantGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TenantGroupByOutputType[P]>
            : GetScalarType<T[P], TenantGroupByOutputType[P]>
        }
      >
    >


  export type TenantSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | Tenant$servicesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tenant"]>



  export type TenantSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TenantOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "createdAt" | "updatedAt", ExtArgs["result"]["tenant"]>
  export type TenantInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Tenant$servicesArgs<ExtArgs>
    _count?: boolean | TenantCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TenantPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Tenant"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["tenant"]>
    composites: {}
  }

  type TenantGetPayload<S extends boolean | null | undefined | TenantDefaultArgs> = $Result.GetResult<Prisma.$TenantPayload, S>

  type TenantCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TenantFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TenantCountAggregateInputType | true
    }

  export interface TenantDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Tenant'], meta: { name: 'Tenant' } }
    /**
     * Find zero or one Tenant that matches the filter.
     * @param {TenantFindUniqueArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TenantFindUniqueArgs>(args: SelectSubset<T, TenantFindUniqueArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Tenant that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TenantFindUniqueOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TenantFindUniqueOrThrowArgs>(args: SelectSubset<T, TenantFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TenantFindFirstArgs>(args?: SelectSubset<T, TenantFindFirstArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Tenant that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindFirstOrThrowArgs} args - Arguments to find a Tenant
     * @example
     * // Get one Tenant
     * const tenant = await prisma.tenant.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TenantFindFirstOrThrowArgs>(args?: SelectSubset<T, TenantFindFirstOrThrowArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tenants
     * const tenants = await prisma.tenant.findMany()
     * 
     * // Get first 10 Tenants
     * const tenants = await prisma.tenant.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tenantWithIdOnly = await prisma.tenant.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TenantFindManyArgs>(args?: SelectSubset<T, TenantFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Tenant.
     * @param {TenantCreateArgs} args - Arguments to create a Tenant.
     * @example
     * // Create one Tenant
     * const Tenant = await prisma.tenant.create({
     *   data: {
     *     // ... data to create a Tenant
     *   }
     * })
     * 
     */
    create<T extends TenantCreateArgs>(args: SelectSubset<T, TenantCreateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Tenants.
     * @param {TenantCreateManyArgs} args - Arguments to create many Tenants.
     * @example
     * // Create many Tenants
     * const tenant = await prisma.tenant.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TenantCreateManyArgs>(args?: SelectSubset<T, TenantCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Tenant.
     * @param {TenantDeleteArgs} args - Arguments to delete one Tenant.
     * @example
     * // Delete one Tenant
     * const Tenant = await prisma.tenant.delete({
     *   where: {
     *     // ... filter to delete one Tenant
     *   }
     * })
     * 
     */
    delete<T extends TenantDeleteArgs>(args: SelectSubset<T, TenantDeleteArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Tenant.
     * @param {TenantUpdateArgs} args - Arguments to update one Tenant.
     * @example
     * // Update one Tenant
     * const tenant = await prisma.tenant.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TenantUpdateArgs>(args: SelectSubset<T, TenantUpdateArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Tenants.
     * @param {TenantDeleteManyArgs} args - Arguments to filter Tenants to delete.
     * @example
     * // Delete a few Tenants
     * const { count } = await prisma.tenant.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TenantDeleteManyArgs>(args?: SelectSubset<T, TenantDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tenants
     * const tenant = await prisma.tenant.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TenantUpdateManyArgs>(args: SelectSubset<T, TenantUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tenant.
     * @param {TenantUpsertArgs} args - Arguments to update or create a Tenant.
     * @example
     * // Update or create a Tenant
     * const tenant = await prisma.tenant.upsert({
     *   create: {
     *     // ... data to create a Tenant
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tenant we want to update
     *   }
     * })
     */
    upsert<T extends TenantUpsertArgs>(args: SelectSubset<T, TenantUpsertArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Tenants that matches the filter.
     * @param {TenantFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const tenant = await prisma.tenant.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: TenantFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Tenant.
     * @param {TenantAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const tenant = await prisma.tenant.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: TenantAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Tenants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantCountArgs} args - Arguments to filter Tenants to count.
     * @example
     * // Count the number of Tenants
     * const count = await prisma.tenant.count({
     *   where: {
     *     // ... the filter for the Tenants we want to count
     *   }
     * })
    **/
    count<T extends TenantCountArgs>(
      args?: Subset<T, TenantCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TenantCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TenantAggregateArgs>(args: Subset<T, TenantAggregateArgs>): Prisma.PrismaPromise<GetTenantAggregateType<T>>

    /**
     * Group by Tenant.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TenantGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TenantGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TenantGroupByArgs['orderBy'] }
        : { orderBy?: TenantGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TenantGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTenantGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Tenant model
   */
  readonly fields: TenantFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Tenant.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TenantClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Tenant$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Tenant$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Tenant model
   */
  interface TenantFieldRefs {
    readonly id: FieldRef<"Tenant", 'String'>
    readonly name: FieldRef<"Tenant", 'String'>
    readonly slug: FieldRef<"Tenant", 'String'>
    readonly createdAt: FieldRef<"Tenant", 'DateTime'>
    readonly updatedAt: FieldRef<"Tenant", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Tenant findUnique
   */
  export type TenantFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findUniqueOrThrow
   */
  export type TenantFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant findFirst
   */
  export type TenantFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findFirstOrThrow
   */
  export type TenantFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenant to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Tenants.
     */
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant findMany
   */
  export type TenantFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter, which Tenants to fetch.
     */
    where?: TenantWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Tenants to fetch.
     */
    orderBy?: TenantOrderByWithRelationInput | TenantOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Tenants.
     */
    cursor?: TenantWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Tenants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Tenants.
     */
    skip?: number
    distinct?: TenantScalarFieldEnum | TenantScalarFieldEnum[]
  }

  /**
   * Tenant create
   */
  export type TenantCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to create a Tenant.
     */
    data: XOR<TenantCreateInput, TenantUncheckedCreateInput>
  }

  /**
   * Tenant createMany
   */
  export type TenantCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Tenants.
     */
    data: TenantCreateManyInput | TenantCreateManyInput[]
  }

  /**
   * Tenant update
   */
  export type TenantUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The data needed to update a Tenant.
     */
    data: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
    /**
     * Choose, which Tenant to update.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant updateMany
   */
  export type TenantUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Tenants.
     */
    data: XOR<TenantUpdateManyMutationInput, TenantUncheckedUpdateManyInput>
    /**
     * Filter which Tenants to update
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to update.
     */
    limit?: number
  }

  /**
   * Tenant upsert
   */
  export type TenantUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * The filter to search for the Tenant to update in case it exists.
     */
    where: TenantWhereUniqueInput
    /**
     * In case the Tenant found by the `where` argument doesn't exist, create a new Tenant with this data.
     */
    create: XOR<TenantCreateInput, TenantUncheckedCreateInput>
    /**
     * In case the Tenant was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TenantUpdateInput, TenantUncheckedUpdateInput>
  }

  /**
   * Tenant delete
   */
  export type TenantDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    /**
     * Filter which Tenant to delete.
     */
    where: TenantWhereUniqueInput
  }

  /**
   * Tenant deleteMany
   */
  export type TenantDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Tenants to delete
     */
    where?: TenantWhereInput
    /**
     * Limit how many Tenants to delete.
     */
    limit?: number
  }

  /**
   * Tenant findRaw
   */
  export type TenantFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tenant aggregateRaw
   */
  export type TenantAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Tenant.services
   */
  export type Tenant$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Tenant without action
   */
  export type TenantDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    userName: string | null
    phonenumber: string | null
    accessToken: string | null
    refreshToken: string | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    name: string | null
    userName: string | null
    phonenumber: string | null
    accessToken: string | null
    refreshToken: string | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    userName: number
    phonenumber: number
    accessToken: number
    refreshToken: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userName?: true
    phonenumber?: true
    accessToken?: true
    refreshToken?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userName?: true
    phonenumber?: true
    accessToken?: true
    refreshToken?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    userName?: true
    phonenumber?: true
    accessToken?: true
    refreshToken?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    name: string | null
    userName: string | null
    phonenumber: string | null
    accessToken: string | null
    refreshToken: string | null
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userName?: boolean
    phonenumber?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    services?: boolean | User$servicesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>



  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    userName?: boolean
    phonenumber?: boolean
    accessToken?: boolean
    refreshToken?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "name" | "userName" | "phonenumber" | "accessToken" | "refreshToken", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | User$servicesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      name: string | null
      userName: string | null
      phonenumber: string | null
      accessToken: string | null
      refreshToken: string | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {UserFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const user = await prisma.user.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: UserFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a User.
     * @param {UserAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const user = await prisma.user.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: UserAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends User$servicesArgs<ExtArgs> = {}>(args?: Subset<T, User$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly userName: FieldRef<"User", 'String'>
    readonly phonenumber: FieldRef<"User", 'String'>
    readonly accessToken: FieldRef<"User", 'String'>
    readonly refreshToken: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User findRaw
   */
  export type UserFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User aggregateRaw
   */
  export type UserAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * User.services
   */
  export type User$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Seller
   */

  export type AggregateSeller = {
    _count: SellerCountAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  export type SellerMinAggregateOutputType = {
    id: string | null
    storeName: string | null
  }

  export type SellerMaxAggregateOutputType = {
    id: string | null
    storeName: string | null
  }

  export type SellerCountAggregateOutputType = {
    id: number
    storeName: number
    _all: number
  }


  export type SellerMinAggregateInputType = {
    id?: true
    storeName?: true
  }

  export type SellerMaxAggregateInputType = {
    id?: true
    storeName?: true
  }

  export type SellerCountAggregateInputType = {
    id?: true
    storeName?: true
    _all?: true
  }

  export type SellerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Seller to aggregate.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sellers
    **/
    _count?: true | SellerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SellerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SellerMaxAggregateInputType
  }

  export type GetSellerAggregateType<T extends SellerAggregateArgs> = {
        [P in keyof T & keyof AggregateSeller]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeller[P]>
      : GetScalarType<T[P], AggregateSeller[P]>
  }




  export type SellerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SellerWhereInput
    orderBy?: SellerOrderByWithAggregationInput | SellerOrderByWithAggregationInput[]
    by: SellerScalarFieldEnum[] | SellerScalarFieldEnum
    having?: SellerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SellerCountAggregateInputType | true
    _min?: SellerMinAggregateInputType
    _max?: SellerMaxAggregateInputType
  }

  export type SellerGroupByOutputType = {
    id: string
    storeName: string
    _count: SellerCountAggregateOutputType | null
    _min: SellerMinAggregateOutputType | null
    _max: SellerMaxAggregateOutputType | null
  }

  type GetSellerGroupByPayload<T extends SellerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SellerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SellerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SellerGroupByOutputType[P]>
            : GetScalarType<T[P], SellerGroupByOutputType[P]>
        }
      >
    >


  export type SellerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    storeName?: boolean
    services?: boolean | Seller$servicesArgs<ExtArgs>
    _count?: boolean | SellerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["seller"]>



  export type SellerSelectScalar = {
    id?: boolean
    storeName?: boolean
  }

  export type SellerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "storeName", ExtArgs["result"]["seller"]>
  export type SellerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Seller$servicesArgs<ExtArgs>
    _count?: boolean | SellerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SellerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Seller"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      storeName: string
    }, ExtArgs["result"]["seller"]>
    composites: {}
  }

  type SellerGetPayload<S extends boolean | null | undefined | SellerDefaultArgs> = $Result.GetResult<Prisma.$SellerPayload, S>

  type SellerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SellerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SellerCountAggregateInputType | true
    }

  export interface SellerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Seller'], meta: { name: 'Seller' } }
    /**
     * Find zero or one Seller that matches the filter.
     * @param {SellerFindUniqueArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SellerFindUniqueArgs>(args: SelectSubset<T, SellerFindUniqueArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Seller that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SellerFindUniqueOrThrowArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SellerFindUniqueOrThrowArgs>(args: SelectSubset<T, SellerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SellerFindFirstArgs>(args?: SelectSubset<T, SellerFindFirstArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Seller that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindFirstOrThrowArgs} args - Arguments to find a Seller
     * @example
     * // Get one Seller
     * const seller = await prisma.seller.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SellerFindFirstOrThrowArgs>(args?: SelectSubset<T, SellerFindFirstOrThrowArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sellers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sellers
     * const sellers = await prisma.seller.findMany()
     * 
     * // Get first 10 Sellers
     * const sellers = await prisma.seller.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sellerWithIdOnly = await prisma.seller.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SellerFindManyArgs>(args?: SelectSubset<T, SellerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Seller.
     * @param {SellerCreateArgs} args - Arguments to create a Seller.
     * @example
     * // Create one Seller
     * const Seller = await prisma.seller.create({
     *   data: {
     *     // ... data to create a Seller
     *   }
     * })
     * 
     */
    create<T extends SellerCreateArgs>(args: SelectSubset<T, SellerCreateArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sellers.
     * @param {SellerCreateManyArgs} args - Arguments to create many Sellers.
     * @example
     * // Create many Sellers
     * const seller = await prisma.seller.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SellerCreateManyArgs>(args?: SelectSubset<T, SellerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Seller.
     * @param {SellerDeleteArgs} args - Arguments to delete one Seller.
     * @example
     * // Delete one Seller
     * const Seller = await prisma.seller.delete({
     *   where: {
     *     // ... filter to delete one Seller
     *   }
     * })
     * 
     */
    delete<T extends SellerDeleteArgs>(args: SelectSubset<T, SellerDeleteArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Seller.
     * @param {SellerUpdateArgs} args - Arguments to update one Seller.
     * @example
     * // Update one Seller
     * const seller = await prisma.seller.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SellerUpdateArgs>(args: SelectSubset<T, SellerUpdateArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sellers.
     * @param {SellerDeleteManyArgs} args - Arguments to filter Sellers to delete.
     * @example
     * // Delete a few Sellers
     * const { count } = await prisma.seller.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SellerDeleteManyArgs>(args?: SelectSubset<T, SellerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sellers
     * const seller = await prisma.seller.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SellerUpdateManyArgs>(args: SelectSubset<T, SellerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Seller.
     * @param {SellerUpsertArgs} args - Arguments to update or create a Seller.
     * @example
     * // Update or create a Seller
     * const seller = await prisma.seller.upsert({
     *   create: {
     *     // ... data to create a Seller
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Seller we want to update
     *   }
     * })
     */
    upsert<T extends SellerUpsertArgs>(args: SelectSubset<T, SellerUpsertArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sellers that matches the filter.
     * @param {SellerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const seller = await prisma.seller.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: SellerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Seller.
     * @param {SellerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const seller = await prisma.seller.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: SellerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Sellers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerCountArgs} args - Arguments to filter Sellers to count.
     * @example
     * // Count the number of Sellers
     * const count = await prisma.seller.count({
     *   where: {
     *     // ... the filter for the Sellers we want to count
     *   }
     * })
    **/
    count<T extends SellerCountArgs>(
      args?: Subset<T, SellerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SellerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SellerAggregateArgs>(args: Subset<T, SellerAggregateArgs>): Prisma.PrismaPromise<GetSellerAggregateType<T>>

    /**
     * Group by Seller.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SellerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SellerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SellerGroupByArgs['orderBy'] }
        : { orderBy?: SellerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SellerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSellerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Seller model
   */
  readonly fields: SellerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Seller.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SellerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Seller$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Seller$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Seller model
   */
  interface SellerFieldRefs {
    readonly id: FieldRef<"Seller", 'String'>
    readonly storeName: FieldRef<"Seller", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Seller findUnique
   */
  export type SellerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller findUniqueOrThrow
   */
  export type SellerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller findFirst
   */
  export type SellerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     */
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller findFirstOrThrow
   */
  export type SellerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Seller to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sellers.
     */
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller findMany
   */
  export type SellerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter, which Sellers to fetch.
     */
    where?: SellerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sellers to fetch.
     */
    orderBy?: SellerOrderByWithRelationInput | SellerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sellers.
     */
    cursor?: SellerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sellers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sellers.
     */
    skip?: number
    distinct?: SellerScalarFieldEnum | SellerScalarFieldEnum[]
  }

  /**
   * Seller create
   */
  export type SellerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The data needed to create a Seller.
     */
    data: XOR<SellerCreateInput, SellerUncheckedCreateInput>
  }

  /**
   * Seller createMany
   */
  export type SellerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sellers.
     */
    data: SellerCreateManyInput | SellerCreateManyInput[]
  }

  /**
   * Seller update
   */
  export type SellerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The data needed to update a Seller.
     */
    data: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
    /**
     * Choose, which Seller to update.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller updateMany
   */
  export type SellerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sellers.
     */
    data: XOR<SellerUpdateManyMutationInput, SellerUncheckedUpdateManyInput>
    /**
     * Filter which Sellers to update
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to update.
     */
    limit?: number
  }

  /**
   * Seller upsert
   */
  export type SellerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * The filter to search for the Seller to update in case it exists.
     */
    where: SellerWhereUniqueInput
    /**
     * In case the Seller found by the `where` argument doesn't exist, create a new Seller with this data.
     */
    create: XOR<SellerCreateInput, SellerUncheckedCreateInput>
    /**
     * In case the Seller was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SellerUpdateInput, SellerUncheckedUpdateInput>
  }

  /**
   * Seller delete
   */
  export type SellerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    /**
     * Filter which Seller to delete.
     */
    where: SellerWhereUniqueInput
  }

  /**
   * Seller deleteMany
   */
  export type SellerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sellers to delete
     */
    where?: SellerWhereInput
    /**
     * Limit how many Sellers to delete.
     */
    limit?: number
  }

  /**
   * Seller findRaw
   */
  export type SellerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Seller aggregateRaw
   */
  export type SellerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Seller.services
   */
  export type Seller$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Seller without action
   */
  export type SellerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    taxRateBps: number | null
    durationMin: number | null
    bufferBeforeMin: number | null
    bufferAfterMin: number | null
    minStaffCount: number | null
    maxStaffCount: number | null
    depositAmount: number | null
    displayOrder: number | null
  }

  export type ServiceSumAggregateOutputType = {
    taxRateBps: number | null
    durationMin: number | null
    bufferBeforeMin: number | null
    bufferAfterMin: number | null
    minStaffCount: number | null
    maxStaffCount: number | null
    depositAmount: number | null
    displayOrder: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    sellerId: string | null
    code: string | null
    title: string | null
    description: string | null
    slug: string | null
    pricingType: $Enums.PricingType | null
    currency: string | null
    displayPrice: boolean | null
    taxIncluded: boolean | null
    taxRateBps: number | null
    durationMin: number | null
    bufferBeforeMin: number | null
    bufferAfterMin: number | null
    minStaffCount: number | null
    maxStaffCount: number | null
    isBookable: boolean | null
    requiresDeposit: boolean | null
    depositAmount: number | null
    featured: boolean | null
    badge: string | null
    highlightColor: string | null
    displayOrder: number | null
    isActive: boolean | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    userId: string | null
    sellerId: string | null
    code: string | null
    title: string | null
    description: string | null
    slug: string | null
    pricingType: $Enums.PricingType | null
    currency: string | null
    displayPrice: boolean | null
    taxIncluded: boolean | null
    taxRateBps: number | null
    durationMin: number | null
    bufferBeforeMin: number | null
    bufferAfterMin: number | null
    minStaffCount: number | null
    maxStaffCount: number | null
    isBookable: boolean | null
    requiresDeposit: boolean | null
    depositAmount: number | null
    featured: boolean | null
    badge: string | null
    highlightColor: string | null
    displayOrder: number | null
    isActive: boolean | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    tenantId: number
    userId: number
    sellerId: number
    code: number
    title: number
    description: number
    slug: number
    tags: number
    pricingType: number
    currency: number
    displayPrice: number
    taxIncluded: number
    taxRateBps: number
    durationMin: number
    bufferBeforeMin: number
    bufferAfterMin: number
    minStaffCount: number
    maxStaffCount: number
    isBookable: number
    requiresDeposit: number
    depositAmount: number
    featured: number
    badge: number
    highlightColor: number
    displayOrder: number
    isActive: number
    metaTitle: number
    metaDescription: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    taxRateBps?: true
    durationMin?: true
    bufferBeforeMin?: true
    bufferAfterMin?: true
    minStaffCount?: true
    maxStaffCount?: true
    depositAmount?: true
    displayOrder?: true
  }

  export type ServiceSumAggregateInputType = {
    taxRateBps?: true
    durationMin?: true
    bufferBeforeMin?: true
    bufferAfterMin?: true
    minStaffCount?: true
    maxStaffCount?: true
    depositAmount?: true
    displayOrder?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    sellerId?: true
    code?: true
    title?: true
    description?: true
    slug?: true
    pricingType?: true
    currency?: true
    displayPrice?: true
    taxIncluded?: true
    taxRateBps?: true
    durationMin?: true
    bufferBeforeMin?: true
    bufferAfterMin?: true
    minStaffCount?: true
    maxStaffCount?: true
    isBookable?: true
    requiresDeposit?: true
    depositAmount?: true
    featured?: true
    badge?: true
    highlightColor?: true
    displayOrder?: true
    isActive?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    sellerId?: true
    code?: true
    title?: true
    description?: true
    slug?: true
    pricingType?: true
    currency?: true
    displayPrice?: true
    taxIncluded?: true
    taxRateBps?: true
    durationMin?: true
    bufferBeforeMin?: true
    bufferAfterMin?: true
    minStaffCount?: true
    maxStaffCount?: true
    isBookable?: true
    requiresDeposit?: true
    depositAmount?: true
    featured?: true
    badge?: true
    highlightColor?: true
    displayOrder?: true
    isActive?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    tenantId?: true
    userId?: true
    sellerId?: true
    code?: true
    title?: true
    description?: true
    slug?: true
    tags?: true
    pricingType?: true
    currency?: true
    displayPrice?: true
    taxIncluded?: true
    taxRateBps?: true
    durationMin?: true
    bufferBeforeMin?: true
    bufferAfterMin?: true
    minStaffCount?: true
    maxStaffCount?: true
    isBookable?: true
    requiresDeposit?: true
    depositAmount?: true
    featured?: true
    badge?: true
    highlightColor?: true
    displayOrder?: true
    isActive?: true
    metaTitle?: true
    metaDescription?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    tenantId: string | null
    userId: string | null
    sellerId: string | null
    code: string | null
    title: string | null
    description: string | null
    slug: string | null
    tags: string[]
    pricingType: $Enums.PricingType | null
    currency: string | null
    displayPrice: boolean | null
    taxIncluded: boolean | null
    taxRateBps: number | null
    durationMin: number | null
    bufferBeforeMin: number | null
    bufferAfterMin: number | null
    minStaffCount: number | null
    maxStaffCount: number | null
    isBookable: boolean | null
    requiresDeposit: boolean | null
    depositAmount: number | null
    featured: boolean | null
    badge: string | null
    highlightColor: string | null
    displayOrder: number | null
    isActive: boolean | null
    metaTitle: string | null
    metaDescription: string | null
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    sellerId?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    tags?: boolean
    pricingType?: boolean
    currency?: boolean
    displayPrice?: boolean
    taxIncluded?: boolean
    taxRateBps?: boolean
    durationMin?: boolean
    bufferBeforeMin?: boolean
    bufferAfterMin?: boolean
    minStaffCount?: boolean
    maxStaffCount?: boolean
    isBookable?: boolean
    requiresDeposit?: boolean
    depositAmount?: boolean
    featured?: boolean
    badge?: boolean
    highlightColor?: boolean
    displayOrder?: boolean
    isActive?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    tenant?: boolean | Service$tenantArgs<ExtArgs>
    user?: boolean | Service$userArgs<ExtArgs>
    seller?: boolean | Service$sellerArgs<ExtArgs>
    pricingRules?: boolean | Service$pricingRulesArgs<ExtArgs>
    medias?: boolean | Service$mediasArgs<ExtArgs>
    evaluation?: boolean | Service$evaluationArgs<ExtArgs>
    rating?: boolean | Service$ratingArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>



  export type ServiceSelectScalar = {
    id?: boolean
    tenantId?: boolean
    userId?: boolean
    sellerId?: boolean
    code?: boolean
    title?: boolean
    description?: boolean
    slug?: boolean
    tags?: boolean
    pricingType?: boolean
    currency?: boolean
    displayPrice?: boolean
    taxIncluded?: boolean
    taxRateBps?: boolean
    durationMin?: boolean
    bufferBeforeMin?: boolean
    bufferAfterMin?: boolean
    minStaffCount?: boolean
    maxStaffCount?: boolean
    isBookable?: boolean
    requiresDeposit?: boolean
    depositAmount?: boolean
    featured?: boolean
    badge?: boolean
    highlightColor?: boolean
    displayOrder?: boolean
    isActive?: boolean
    metaTitle?: boolean
    metaDescription?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "userId" | "sellerId" | "code" | "title" | "description" | "slug" | "tags" | "pricingType" | "currency" | "displayPrice" | "taxIncluded" | "taxRateBps" | "durationMin" | "bufferBeforeMin" | "bufferAfterMin" | "minStaffCount" | "maxStaffCount" | "isBookable" | "requiresDeposit" | "depositAmount" | "featured" | "badge" | "highlightColor" | "displayOrder" | "isActive" | "metaTitle" | "metaDescription" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tenant?: boolean | Service$tenantArgs<ExtArgs>
    user?: boolean | Service$userArgs<ExtArgs>
    seller?: boolean | Service$sellerArgs<ExtArgs>
    pricingRules?: boolean | Service$pricingRulesArgs<ExtArgs>
    medias?: boolean | Service$mediasArgs<ExtArgs>
    evaluation?: boolean | Service$evaluationArgs<ExtArgs>
    rating?: boolean | Service$ratingArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      tenant: Prisma.$TenantPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs> | null
      seller: Prisma.$SellerPayload<ExtArgs> | null
      pricingRules: Prisma.$ServicePricingRulePayload<ExtArgs>[]
      medias: Prisma.$ServiceMediaPayload<ExtArgs>[]
      evaluation: Prisma.$ServiceEvaluationPayload<ExtArgs>[]
      rating: Prisma.$ServiceRatingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      userId: string | null
      sellerId: string | null
      code: string | null
      title: string | null
      description: string | null
      slug: string | null
      tags: string[]
      pricingType: $Enums.PricingType | null
      currency: string | null
      displayPrice: boolean | null
      taxIncluded: boolean | null
      taxRateBps: number | null
      durationMin: number | null
      bufferBeforeMin: number | null
      bufferAfterMin: number | null
      minStaffCount: number | null
      maxStaffCount: number | null
      isBookable: boolean | null
      requiresDeposit: boolean | null
      depositAmount: number | null
      featured: boolean | null
      badge: string | null
      highlightColor: string | null
      displayOrder: number | null
      isActive: boolean | null
      metaTitle: string | null
      metaDescription: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * @param {ServiceFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const service = await prisma.service.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Service.
     * @param {ServiceAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const service = await prisma.service.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    tenant<T extends Service$tenantArgs<ExtArgs> = {}>(args?: Subset<T, Service$tenantArgs<ExtArgs>>): Prisma__TenantClient<$Result.GetResult<Prisma.$TenantPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends Service$userArgs<ExtArgs> = {}>(args?: Subset<T, Service$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    seller<T extends Service$sellerArgs<ExtArgs> = {}>(args?: Subset<T, Service$sellerArgs<ExtArgs>>): Prisma__SellerClient<$Result.GetResult<Prisma.$SellerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    pricingRules<T extends Service$pricingRulesArgs<ExtArgs> = {}>(args?: Subset<T, Service$pricingRulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    medias<T extends Service$mediasArgs<ExtArgs> = {}>(args?: Subset<T, Service$mediasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    evaluation<T extends Service$evaluationArgs<ExtArgs> = {}>(args?: Subset<T, Service$evaluationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    rating<T extends Service$ratingArgs<ExtArgs> = {}>(args?: Subset<T, Service$ratingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly tenantId: FieldRef<"Service", 'String'>
    readonly userId: FieldRef<"Service", 'String'>
    readonly sellerId: FieldRef<"Service", 'String'>
    readonly code: FieldRef<"Service", 'String'>
    readonly title: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly slug: FieldRef<"Service", 'String'>
    readonly tags: FieldRef<"Service", 'String[]'>
    readonly pricingType: FieldRef<"Service", 'PricingType'>
    readonly currency: FieldRef<"Service", 'String'>
    readonly displayPrice: FieldRef<"Service", 'Boolean'>
    readonly taxIncluded: FieldRef<"Service", 'Boolean'>
    readonly taxRateBps: FieldRef<"Service", 'Int'>
    readonly durationMin: FieldRef<"Service", 'Int'>
    readonly bufferBeforeMin: FieldRef<"Service", 'Int'>
    readonly bufferAfterMin: FieldRef<"Service", 'Int'>
    readonly minStaffCount: FieldRef<"Service", 'Int'>
    readonly maxStaffCount: FieldRef<"Service", 'Int'>
    readonly isBookable: FieldRef<"Service", 'Boolean'>
    readonly requiresDeposit: FieldRef<"Service", 'Boolean'>
    readonly depositAmount: FieldRef<"Service", 'Int'>
    readonly featured: FieldRef<"Service", 'Boolean'>
    readonly badge: FieldRef<"Service", 'String'>
    readonly highlightColor: FieldRef<"Service", 'String'>
    readonly displayOrder: FieldRef<"Service", 'Int'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly metaTitle: FieldRef<"Service", 'String'>
    readonly metaDescription: FieldRef<"Service", 'String'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service findRaw
   */
  export type ServiceFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service aggregateRaw
   */
  export type ServiceAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * Service.tenant
   */
  export type Service$tenantArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Tenant
     */
    select?: TenantSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Tenant
     */
    omit?: TenantOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TenantInclude<ExtArgs> | null
    where?: TenantWhereInput
  }

  /**
   * Service.user
   */
  export type Service$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Service.seller
   */
  export type Service$sellerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Seller
     */
    select?: SellerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Seller
     */
    omit?: SellerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SellerInclude<ExtArgs> | null
    where?: SellerWhereInput
  }

  /**
   * Service.pricingRules
   */
  export type Service$pricingRulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    where?: ServicePricingRuleWhereInput
    orderBy?: ServicePricingRuleOrderByWithRelationInput | ServicePricingRuleOrderByWithRelationInput[]
    cursor?: ServicePricingRuleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePricingRuleScalarFieldEnum | ServicePricingRuleScalarFieldEnum[]
  }

  /**
   * Service.medias
   */
  export type Service$mediasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    where?: ServiceMediaWhereInput
    orderBy?: ServiceMediaOrderByWithRelationInput | ServiceMediaOrderByWithRelationInput[]
    cursor?: ServiceMediaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceMediaScalarFieldEnum | ServiceMediaScalarFieldEnum[]
  }

  /**
   * Service.evaluation
   */
  export type Service$evaluationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    where?: ServiceEvaluationWhereInput
    orderBy?: ServiceEvaluationOrderByWithRelationInput | ServiceEvaluationOrderByWithRelationInput[]
    cursor?: ServiceEvaluationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceEvaluationScalarFieldEnum | ServiceEvaluationScalarFieldEnum[]
  }

  /**
   * Service.rating
   */
  export type Service$ratingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    where?: ServiceRatingWhereInput
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    cursor?: ServiceRatingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model ServiceMedia
   */

  export type AggregateServiceMedia = {
    _count: ServiceMediaCountAggregateOutputType | null
    _avg: ServiceMediaAvgAggregateOutputType | null
    _sum: ServiceMediaSumAggregateOutputType | null
    _min: ServiceMediaMinAggregateOutputType | null
    _max: ServiceMediaMaxAggregateOutputType | null
  }

  export type ServiceMediaAvgAggregateOutputType = {
    order: number | null
  }

  export type ServiceMediaSumAggregateOutputType = {
    order: number | null
  }

  export type ServiceMediaMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceId: string | null
    url: string | null
    alt: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ServiceMediaMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceId: string | null
    url: string | null
    alt: string | null
    order: number | null
    createdAt: Date | null
  }

  export type ServiceMediaCountAggregateOutputType = {
    id: number
    tenantId: number
    serviceId: number
    url: number
    alt: number
    order: number
    createdAt: number
    _all: number
  }


  export type ServiceMediaAvgAggregateInputType = {
    order?: true
  }

  export type ServiceMediaSumAggregateInputType = {
    order?: true
  }

  export type ServiceMediaMinAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    url?: true
    alt?: true
    order?: true
    createdAt?: true
  }

  export type ServiceMediaMaxAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    url?: true
    alt?: true
    order?: true
    createdAt?: true
  }

  export type ServiceMediaCountAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    url?: true
    alt?: true
    order?: true
    createdAt?: true
    _all?: true
  }

  export type ServiceMediaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceMedia to aggregate.
     */
    where?: ServiceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceMedias to fetch.
     */
    orderBy?: ServiceMediaOrderByWithRelationInput | ServiceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceMedias
    **/
    _count?: true | ServiceMediaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceMediaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceMediaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMediaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMediaMaxAggregateInputType
  }

  export type GetServiceMediaAggregateType<T extends ServiceMediaAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceMedia]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceMedia[P]>
      : GetScalarType<T[P], AggregateServiceMedia[P]>
  }




  export type ServiceMediaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceMediaWhereInput
    orderBy?: ServiceMediaOrderByWithAggregationInput | ServiceMediaOrderByWithAggregationInput[]
    by: ServiceMediaScalarFieldEnum[] | ServiceMediaScalarFieldEnum
    having?: ServiceMediaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceMediaCountAggregateInputType | true
    _avg?: ServiceMediaAvgAggregateInputType
    _sum?: ServiceMediaSumAggregateInputType
    _min?: ServiceMediaMinAggregateInputType
    _max?: ServiceMediaMaxAggregateInputType
  }

  export type ServiceMediaGroupByOutputType = {
    id: string
    tenantId: string | null
    serviceId: string | null
    url: string | null
    alt: string | null
    order: number
    createdAt: Date
    _count: ServiceMediaCountAggregateOutputType | null
    _avg: ServiceMediaAvgAggregateOutputType | null
    _sum: ServiceMediaSumAggregateOutputType | null
    _min: ServiceMediaMinAggregateOutputType | null
    _max: ServiceMediaMaxAggregateOutputType | null
  }

  type GetServiceMediaGroupByPayload<T extends ServiceMediaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceMediaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceMediaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceMediaGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceMediaGroupByOutputType[P]>
        }
      >
    >


  export type ServiceMediaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    url?: boolean
    alt?: boolean
    order?: boolean
    createdAt?: boolean
    service?: boolean | ServiceMedia$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["serviceMedia"]>



  export type ServiceMediaSelectScalar = {
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    url?: boolean
    alt?: boolean
    order?: boolean
    createdAt?: boolean
  }

  export type ServiceMediaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "serviceId" | "url" | "alt" | "order" | "createdAt", ExtArgs["result"]["serviceMedia"]>
  export type ServiceMediaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceMedia$serviceArgs<ExtArgs>
  }

  export type $ServiceMediaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceMedia"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      serviceId: string | null
      url: string | null
      alt: string | null
      order: number
      createdAt: Date
    }, ExtArgs["result"]["serviceMedia"]>
    composites: {}
  }

  type ServiceMediaGetPayload<S extends boolean | null | undefined | ServiceMediaDefaultArgs> = $Result.GetResult<Prisma.$ServiceMediaPayload, S>

  type ServiceMediaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceMediaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceMediaCountAggregateInputType | true
    }

  export interface ServiceMediaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceMedia'], meta: { name: 'ServiceMedia' } }
    /**
     * Find zero or one ServiceMedia that matches the filter.
     * @param {ServiceMediaFindUniqueArgs} args - Arguments to find a ServiceMedia
     * @example
     * // Get one ServiceMedia
     * const serviceMedia = await prisma.serviceMedia.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceMediaFindUniqueArgs>(args: SelectSubset<T, ServiceMediaFindUniqueArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceMedia that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceMediaFindUniqueOrThrowArgs} args - Arguments to find a ServiceMedia
     * @example
     * // Get one ServiceMedia
     * const serviceMedia = await prisma.serviceMedia.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceMediaFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceMediaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceMedia that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaFindFirstArgs} args - Arguments to find a ServiceMedia
     * @example
     * // Get one ServiceMedia
     * const serviceMedia = await prisma.serviceMedia.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceMediaFindFirstArgs>(args?: SelectSubset<T, ServiceMediaFindFirstArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceMedia that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaFindFirstOrThrowArgs} args - Arguments to find a ServiceMedia
     * @example
     * // Get one ServiceMedia
     * const serviceMedia = await prisma.serviceMedia.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceMediaFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceMediaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceMedias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceMedias
     * const serviceMedias = await prisma.serviceMedia.findMany()
     * 
     * // Get first 10 ServiceMedias
     * const serviceMedias = await prisma.serviceMedia.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceMediaWithIdOnly = await prisma.serviceMedia.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceMediaFindManyArgs>(args?: SelectSubset<T, ServiceMediaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceMedia.
     * @param {ServiceMediaCreateArgs} args - Arguments to create a ServiceMedia.
     * @example
     * // Create one ServiceMedia
     * const ServiceMedia = await prisma.serviceMedia.create({
     *   data: {
     *     // ... data to create a ServiceMedia
     *   }
     * })
     * 
     */
    create<T extends ServiceMediaCreateArgs>(args: SelectSubset<T, ServiceMediaCreateArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceMedias.
     * @param {ServiceMediaCreateManyArgs} args - Arguments to create many ServiceMedias.
     * @example
     * // Create many ServiceMedias
     * const serviceMedia = await prisma.serviceMedia.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceMediaCreateManyArgs>(args?: SelectSubset<T, ServiceMediaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceMedia.
     * @param {ServiceMediaDeleteArgs} args - Arguments to delete one ServiceMedia.
     * @example
     * // Delete one ServiceMedia
     * const ServiceMedia = await prisma.serviceMedia.delete({
     *   where: {
     *     // ... filter to delete one ServiceMedia
     *   }
     * })
     * 
     */
    delete<T extends ServiceMediaDeleteArgs>(args: SelectSubset<T, ServiceMediaDeleteArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceMedia.
     * @param {ServiceMediaUpdateArgs} args - Arguments to update one ServiceMedia.
     * @example
     * // Update one ServiceMedia
     * const serviceMedia = await prisma.serviceMedia.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceMediaUpdateArgs>(args: SelectSubset<T, ServiceMediaUpdateArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceMedias.
     * @param {ServiceMediaDeleteManyArgs} args - Arguments to filter ServiceMedias to delete.
     * @example
     * // Delete a few ServiceMedias
     * const { count } = await prisma.serviceMedia.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceMediaDeleteManyArgs>(args?: SelectSubset<T, ServiceMediaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceMedias
     * const serviceMedia = await prisma.serviceMedia.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceMediaUpdateManyArgs>(args: SelectSubset<T, ServiceMediaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceMedia.
     * @param {ServiceMediaUpsertArgs} args - Arguments to update or create a ServiceMedia.
     * @example
     * // Update or create a ServiceMedia
     * const serviceMedia = await prisma.serviceMedia.upsert({
     *   create: {
     *     // ... data to create a ServiceMedia
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceMedia we want to update
     *   }
     * })
     */
    upsert<T extends ServiceMediaUpsertArgs>(args: SelectSubset<T, ServiceMediaUpsertArgs<ExtArgs>>): Prisma__ServiceMediaClient<$Result.GetResult<Prisma.$ServiceMediaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceMedias that matches the filter.
     * @param {ServiceMediaFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviceMedia = await prisma.serviceMedia.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceMediaFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiceMedia.
     * @param {ServiceMediaAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviceMedia = await prisma.serviceMedia.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceMediaAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiceMedias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaCountArgs} args - Arguments to filter ServiceMedias to count.
     * @example
     * // Count the number of ServiceMedias
     * const count = await prisma.serviceMedia.count({
     *   where: {
     *     // ... the filter for the ServiceMedias we want to count
     *   }
     * })
    **/
    count<T extends ServiceMediaCountArgs>(
      args?: Subset<T, ServiceMediaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceMediaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceMediaAggregateArgs>(args: Subset<T, ServiceMediaAggregateArgs>): Prisma.PrismaPromise<GetServiceMediaAggregateType<T>>

    /**
     * Group by ServiceMedia.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceMediaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceMediaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceMediaGroupByArgs['orderBy'] }
        : { orderBy?: ServiceMediaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceMediaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceMediaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceMedia model
   */
  readonly fields: ServiceMediaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceMedia.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceMediaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceMedia$serviceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceMedia$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceMedia model
   */
  interface ServiceMediaFieldRefs {
    readonly id: FieldRef<"ServiceMedia", 'String'>
    readonly tenantId: FieldRef<"ServiceMedia", 'String'>
    readonly serviceId: FieldRef<"ServiceMedia", 'String'>
    readonly url: FieldRef<"ServiceMedia", 'String'>
    readonly alt: FieldRef<"ServiceMedia", 'String'>
    readonly order: FieldRef<"ServiceMedia", 'Int'>
    readonly createdAt: FieldRef<"ServiceMedia", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServiceMedia findUnique
   */
  export type ServiceMediaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * Filter, which ServiceMedia to fetch.
     */
    where: ServiceMediaWhereUniqueInput
  }

  /**
   * ServiceMedia findUniqueOrThrow
   */
  export type ServiceMediaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * Filter, which ServiceMedia to fetch.
     */
    where: ServiceMediaWhereUniqueInput
  }

  /**
   * ServiceMedia findFirst
   */
  export type ServiceMediaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * Filter, which ServiceMedia to fetch.
     */
    where?: ServiceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceMedias to fetch.
     */
    orderBy?: ServiceMediaOrderByWithRelationInput | ServiceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceMedias.
     */
    cursor?: ServiceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceMedias.
     */
    distinct?: ServiceMediaScalarFieldEnum | ServiceMediaScalarFieldEnum[]
  }

  /**
   * ServiceMedia findFirstOrThrow
   */
  export type ServiceMediaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * Filter, which ServiceMedia to fetch.
     */
    where?: ServiceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceMedias to fetch.
     */
    orderBy?: ServiceMediaOrderByWithRelationInput | ServiceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceMedias.
     */
    cursor?: ServiceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceMedias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceMedias.
     */
    distinct?: ServiceMediaScalarFieldEnum | ServiceMediaScalarFieldEnum[]
  }

  /**
   * ServiceMedia findMany
   */
  export type ServiceMediaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * Filter, which ServiceMedias to fetch.
     */
    where?: ServiceMediaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceMedias to fetch.
     */
    orderBy?: ServiceMediaOrderByWithRelationInput | ServiceMediaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceMedias.
     */
    cursor?: ServiceMediaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceMedias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceMedias.
     */
    skip?: number
    distinct?: ServiceMediaScalarFieldEnum | ServiceMediaScalarFieldEnum[]
  }

  /**
   * ServiceMedia create
   */
  export type ServiceMediaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceMedia.
     */
    data?: XOR<ServiceMediaCreateInput, ServiceMediaUncheckedCreateInput>
  }

  /**
   * ServiceMedia createMany
   */
  export type ServiceMediaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceMedias.
     */
    data: ServiceMediaCreateManyInput | ServiceMediaCreateManyInput[]
  }

  /**
   * ServiceMedia update
   */
  export type ServiceMediaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceMedia.
     */
    data: XOR<ServiceMediaUpdateInput, ServiceMediaUncheckedUpdateInput>
    /**
     * Choose, which ServiceMedia to update.
     */
    where: ServiceMediaWhereUniqueInput
  }

  /**
   * ServiceMedia updateMany
   */
  export type ServiceMediaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceMedias.
     */
    data: XOR<ServiceMediaUpdateManyMutationInput, ServiceMediaUncheckedUpdateManyInput>
    /**
     * Filter which ServiceMedias to update
     */
    where?: ServiceMediaWhereInput
    /**
     * Limit how many ServiceMedias to update.
     */
    limit?: number
  }

  /**
   * ServiceMedia upsert
   */
  export type ServiceMediaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceMedia to update in case it exists.
     */
    where: ServiceMediaWhereUniqueInput
    /**
     * In case the ServiceMedia found by the `where` argument doesn't exist, create a new ServiceMedia with this data.
     */
    create: XOR<ServiceMediaCreateInput, ServiceMediaUncheckedCreateInput>
    /**
     * In case the ServiceMedia was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceMediaUpdateInput, ServiceMediaUncheckedUpdateInput>
  }

  /**
   * ServiceMedia delete
   */
  export type ServiceMediaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
    /**
     * Filter which ServiceMedia to delete.
     */
    where: ServiceMediaWhereUniqueInput
  }

  /**
   * ServiceMedia deleteMany
   */
  export type ServiceMediaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceMedias to delete
     */
    where?: ServiceMediaWhereInput
    /**
     * Limit how many ServiceMedias to delete.
     */
    limit?: number
  }

  /**
   * ServiceMedia findRaw
   */
  export type ServiceMediaFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceMedia aggregateRaw
   */
  export type ServiceMediaAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceMedia.service
   */
  export type ServiceMedia$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * ServiceMedia without action
   */
  export type ServiceMediaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceMedia
     */
    select?: ServiceMediaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceMedia
     */
    omit?: ServiceMediaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceMediaInclude<ExtArgs> | null
  }


  /**
   * Model ServiceEvaluation
   */

  export type AggregateServiceEvaluation = {
    _count: ServiceEvaluationCountAggregateOutputType | null
    _min: ServiceEvaluationMinAggregateOutputType | null
    _max: ServiceEvaluationMaxAggregateOutputType | null
  }

  export type ServiceEvaluationMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    createdAt: Date | null
    userId: string | null
    evaluationContent: string | null
  }

  export type ServiceEvaluationMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    createdAt: Date | null
    userId: string | null
    evaluationContent: string | null
  }

  export type ServiceEvaluationCountAggregateOutputType = {
    id: number
    serviceId: number
    createdAt: number
    userId: number
    evaluationContent: number
    _all: number
  }


  export type ServiceEvaluationMinAggregateInputType = {
    id?: true
    serviceId?: true
    createdAt?: true
    userId?: true
    evaluationContent?: true
  }

  export type ServiceEvaluationMaxAggregateInputType = {
    id?: true
    serviceId?: true
    createdAt?: true
    userId?: true
    evaluationContent?: true
  }

  export type ServiceEvaluationCountAggregateInputType = {
    id?: true
    serviceId?: true
    createdAt?: true
    userId?: true
    evaluationContent?: true
    _all?: true
  }

  export type ServiceEvaluationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceEvaluation to aggregate.
     */
    where?: ServiceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceEvaluations to fetch.
     */
    orderBy?: ServiceEvaluationOrderByWithRelationInput | ServiceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceEvaluations
    **/
    _count?: true | ServiceEvaluationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceEvaluationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceEvaluationMaxAggregateInputType
  }

  export type GetServiceEvaluationAggregateType<T extends ServiceEvaluationAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceEvaluation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceEvaluation[P]>
      : GetScalarType<T[P], AggregateServiceEvaluation[P]>
  }




  export type ServiceEvaluationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceEvaluationWhereInput
    orderBy?: ServiceEvaluationOrderByWithAggregationInput | ServiceEvaluationOrderByWithAggregationInput[]
    by: ServiceEvaluationScalarFieldEnum[] | ServiceEvaluationScalarFieldEnum
    having?: ServiceEvaluationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceEvaluationCountAggregateInputType | true
    _min?: ServiceEvaluationMinAggregateInputType
    _max?: ServiceEvaluationMaxAggregateInputType
  }

  export type ServiceEvaluationGroupByOutputType = {
    id: string
    serviceId: string | null
    createdAt: Date
    userId: string | null
    evaluationContent: string | null
    _count: ServiceEvaluationCountAggregateOutputType | null
    _min: ServiceEvaluationMinAggregateOutputType | null
    _max: ServiceEvaluationMaxAggregateOutputType | null
  }

  type GetServiceEvaluationGroupByPayload<T extends ServiceEvaluationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceEvaluationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceEvaluationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceEvaluationGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceEvaluationGroupByOutputType[P]>
        }
      >
    >


  export type ServiceEvaluationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    createdAt?: boolean
    userId?: boolean
    evaluationContent?: boolean
    service?: boolean | ServiceEvaluation$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["serviceEvaluation"]>



  export type ServiceEvaluationSelectScalar = {
    id?: boolean
    serviceId?: boolean
    createdAt?: boolean
    userId?: boolean
    evaluationContent?: boolean
  }

  export type ServiceEvaluationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "createdAt" | "userId" | "evaluationContent", ExtArgs["result"]["serviceEvaluation"]>
  export type ServiceEvaluationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceEvaluation$serviceArgs<ExtArgs>
  }

  export type $ServiceEvaluationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceEvaluation"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string | null
      createdAt: Date
      userId: string | null
      evaluationContent: string | null
    }, ExtArgs["result"]["serviceEvaluation"]>
    composites: {}
  }

  type ServiceEvaluationGetPayload<S extends boolean | null | undefined | ServiceEvaluationDefaultArgs> = $Result.GetResult<Prisma.$ServiceEvaluationPayload, S>

  type ServiceEvaluationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceEvaluationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceEvaluationCountAggregateInputType | true
    }

  export interface ServiceEvaluationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceEvaluation'], meta: { name: 'ServiceEvaluation' } }
    /**
     * Find zero or one ServiceEvaluation that matches the filter.
     * @param {ServiceEvaluationFindUniqueArgs} args - Arguments to find a ServiceEvaluation
     * @example
     * // Get one ServiceEvaluation
     * const serviceEvaluation = await prisma.serviceEvaluation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceEvaluationFindUniqueArgs>(args: SelectSubset<T, ServiceEvaluationFindUniqueArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceEvaluation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceEvaluationFindUniqueOrThrowArgs} args - Arguments to find a ServiceEvaluation
     * @example
     * // Get one ServiceEvaluation
     * const serviceEvaluation = await prisma.serviceEvaluation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceEvaluationFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceEvaluationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceEvaluation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationFindFirstArgs} args - Arguments to find a ServiceEvaluation
     * @example
     * // Get one ServiceEvaluation
     * const serviceEvaluation = await prisma.serviceEvaluation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceEvaluationFindFirstArgs>(args?: SelectSubset<T, ServiceEvaluationFindFirstArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceEvaluation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationFindFirstOrThrowArgs} args - Arguments to find a ServiceEvaluation
     * @example
     * // Get one ServiceEvaluation
     * const serviceEvaluation = await prisma.serviceEvaluation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceEvaluationFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceEvaluationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceEvaluations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceEvaluations
     * const serviceEvaluations = await prisma.serviceEvaluation.findMany()
     * 
     * // Get first 10 ServiceEvaluations
     * const serviceEvaluations = await prisma.serviceEvaluation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceEvaluationWithIdOnly = await prisma.serviceEvaluation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceEvaluationFindManyArgs>(args?: SelectSubset<T, ServiceEvaluationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceEvaluation.
     * @param {ServiceEvaluationCreateArgs} args - Arguments to create a ServiceEvaluation.
     * @example
     * // Create one ServiceEvaluation
     * const ServiceEvaluation = await prisma.serviceEvaluation.create({
     *   data: {
     *     // ... data to create a ServiceEvaluation
     *   }
     * })
     * 
     */
    create<T extends ServiceEvaluationCreateArgs>(args: SelectSubset<T, ServiceEvaluationCreateArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceEvaluations.
     * @param {ServiceEvaluationCreateManyArgs} args - Arguments to create many ServiceEvaluations.
     * @example
     * // Create many ServiceEvaluations
     * const serviceEvaluation = await prisma.serviceEvaluation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceEvaluationCreateManyArgs>(args?: SelectSubset<T, ServiceEvaluationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceEvaluation.
     * @param {ServiceEvaluationDeleteArgs} args - Arguments to delete one ServiceEvaluation.
     * @example
     * // Delete one ServiceEvaluation
     * const ServiceEvaluation = await prisma.serviceEvaluation.delete({
     *   where: {
     *     // ... filter to delete one ServiceEvaluation
     *   }
     * })
     * 
     */
    delete<T extends ServiceEvaluationDeleteArgs>(args: SelectSubset<T, ServiceEvaluationDeleteArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceEvaluation.
     * @param {ServiceEvaluationUpdateArgs} args - Arguments to update one ServiceEvaluation.
     * @example
     * // Update one ServiceEvaluation
     * const serviceEvaluation = await prisma.serviceEvaluation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceEvaluationUpdateArgs>(args: SelectSubset<T, ServiceEvaluationUpdateArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceEvaluations.
     * @param {ServiceEvaluationDeleteManyArgs} args - Arguments to filter ServiceEvaluations to delete.
     * @example
     * // Delete a few ServiceEvaluations
     * const { count } = await prisma.serviceEvaluation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceEvaluationDeleteManyArgs>(args?: SelectSubset<T, ServiceEvaluationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceEvaluations
     * const serviceEvaluation = await prisma.serviceEvaluation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceEvaluationUpdateManyArgs>(args: SelectSubset<T, ServiceEvaluationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceEvaluation.
     * @param {ServiceEvaluationUpsertArgs} args - Arguments to update or create a ServiceEvaluation.
     * @example
     * // Update or create a ServiceEvaluation
     * const serviceEvaluation = await prisma.serviceEvaluation.upsert({
     *   create: {
     *     // ... data to create a ServiceEvaluation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceEvaluation we want to update
     *   }
     * })
     */
    upsert<T extends ServiceEvaluationUpsertArgs>(args: SelectSubset<T, ServiceEvaluationUpsertArgs<ExtArgs>>): Prisma__ServiceEvaluationClient<$Result.GetResult<Prisma.$ServiceEvaluationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceEvaluations that matches the filter.
     * @param {ServiceEvaluationFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviceEvaluation = await prisma.serviceEvaluation.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceEvaluationFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiceEvaluation.
     * @param {ServiceEvaluationAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviceEvaluation = await prisma.serviceEvaluation.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceEvaluationAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiceEvaluations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationCountArgs} args - Arguments to filter ServiceEvaluations to count.
     * @example
     * // Count the number of ServiceEvaluations
     * const count = await prisma.serviceEvaluation.count({
     *   where: {
     *     // ... the filter for the ServiceEvaluations we want to count
     *   }
     * })
    **/
    count<T extends ServiceEvaluationCountArgs>(
      args?: Subset<T, ServiceEvaluationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceEvaluationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceEvaluationAggregateArgs>(args: Subset<T, ServiceEvaluationAggregateArgs>): Prisma.PrismaPromise<GetServiceEvaluationAggregateType<T>>

    /**
     * Group by ServiceEvaluation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceEvaluationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceEvaluationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceEvaluationGroupByArgs['orderBy'] }
        : { orderBy?: ServiceEvaluationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceEvaluationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceEvaluationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceEvaluation model
   */
  readonly fields: ServiceEvaluationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceEvaluation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceEvaluationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceEvaluation$serviceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceEvaluation$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceEvaluation model
   */
  interface ServiceEvaluationFieldRefs {
    readonly id: FieldRef<"ServiceEvaluation", 'String'>
    readonly serviceId: FieldRef<"ServiceEvaluation", 'String'>
    readonly createdAt: FieldRef<"ServiceEvaluation", 'DateTime'>
    readonly userId: FieldRef<"ServiceEvaluation", 'String'>
    readonly evaluationContent: FieldRef<"ServiceEvaluation", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ServiceEvaluation findUnique
   */
  export type ServiceEvaluationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceEvaluation to fetch.
     */
    where: ServiceEvaluationWhereUniqueInput
  }

  /**
   * ServiceEvaluation findUniqueOrThrow
   */
  export type ServiceEvaluationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceEvaluation to fetch.
     */
    where: ServiceEvaluationWhereUniqueInput
  }

  /**
   * ServiceEvaluation findFirst
   */
  export type ServiceEvaluationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceEvaluation to fetch.
     */
    where?: ServiceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceEvaluations to fetch.
     */
    orderBy?: ServiceEvaluationOrderByWithRelationInput | ServiceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceEvaluations.
     */
    cursor?: ServiceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceEvaluations.
     */
    distinct?: ServiceEvaluationScalarFieldEnum | ServiceEvaluationScalarFieldEnum[]
  }

  /**
   * ServiceEvaluation findFirstOrThrow
   */
  export type ServiceEvaluationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceEvaluation to fetch.
     */
    where?: ServiceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceEvaluations to fetch.
     */
    orderBy?: ServiceEvaluationOrderByWithRelationInput | ServiceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceEvaluations.
     */
    cursor?: ServiceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceEvaluations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceEvaluations.
     */
    distinct?: ServiceEvaluationScalarFieldEnum | ServiceEvaluationScalarFieldEnum[]
  }

  /**
   * ServiceEvaluation findMany
   */
  export type ServiceEvaluationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * Filter, which ServiceEvaluations to fetch.
     */
    where?: ServiceEvaluationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceEvaluations to fetch.
     */
    orderBy?: ServiceEvaluationOrderByWithRelationInput | ServiceEvaluationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceEvaluations.
     */
    cursor?: ServiceEvaluationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceEvaluations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceEvaluations.
     */
    skip?: number
    distinct?: ServiceEvaluationScalarFieldEnum | ServiceEvaluationScalarFieldEnum[]
  }

  /**
   * ServiceEvaluation create
   */
  export type ServiceEvaluationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceEvaluation.
     */
    data?: XOR<ServiceEvaluationCreateInput, ServiceEvaluationUncheckedCreateInput>
  }

  /**
   * ServiceEvaluation createMany
   */
  export type ServiceEvaluationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceEvaluations.
     */
    data: ServiceEvaluationCreateManyInput | ServiceEvaluationCreateManyInput[]
  }

  /**
   * ServiceEvaluation update
   */
  export type ServiceEvaluationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceEvaluation.
     */
    data: XOR<ServiceEvaluationUpdateInput, ServiceEvaluationUncheckedUpdateInput>
    /**
     * Choose, which ServiceEvaluation to update.
     */
    where: ServiceEvaluationWhereUniqueInput
  }

  /**
   * ServiceEvaluation updateMany
   */
  export type ServiceEvaluationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceEvaluations.
     */
    data: XOR<ServiceEvaluationUpdateManyMutationInput, ServiceEvaluationUncheckedUpdateManyInput>
    /**
     * Filter which ServiceEvaluations to update
     */
    where?: ServiceEvaluationWhereInput
    /**
     * Limit how many ServiceEvaluations to update.
     */
    limit?: number
  }

  /**
   * ServiceEvaluation upsert
   */
  export type ServiceEvaluationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceEvaluation to update in case it exists.
     */
    where: ServiceEvaluationWhereUniqueInput
    /**
     * In case the ServiceEvaluation found by the `where` argument doesn't exist, create a new ServiceEvaluation with this data.
     */
    create: XOR<ServiceEvaluationCreateInput, ServiceEvaluationUncheckedCreateInput>
    /**
     * In case the ServiceEvaluation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceEvaluationUpdateInput, ServiceEvaluationUncheckedUpdateInput>
  }

  /**
   * ServiceEvaluation delete
   */
  export type ServiceEvaluationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
    /**
     * Filter which ServiceEvaluation to delete.
     */
    where: ServiceEvaluationWhereUniqueInput
  }

  /**
   * ServiceEvaluation deleteMany
   */
  export type ServiceEvaluationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceEvaluations to delete
     */
    where?: ServiceEvaluationWhereInput
    /**
     * Limit how many ServiceEvaluations to delete.
     */
    limit?: number
  }

  /**
   * ServiceEvaluation findRaw
   */
  export type ServiceEvaluationFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceEvaluation aggregateRaw
   */
  export type ServiceEvaluationAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceEvaluation.service
   */
  export type ServiceEvaluation$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * ServiceEvaluation without action
   */
  export type ServiceEvaluationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceEvaluation
     */
    select?: ServiceEvaluationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceEvaluation
     */
    omit?: ServiceEvaluationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceEvaluationInclude<ExtArgs> | null
  }


  /**
   * Model ServiceRating
   */

  export type AggregateServiceRating = {
    _count: ServiceRatingCountAggregateOutputType | null
    _avg: ServiceRatingAvgAggregateOutputType | null
    _sum: ServiceRatingSumAggregateOutputType | null
    _min: ServiceRatingMinAggregateOutputType | null
    _max: ServiceRatingMaxAggregateOutputType | null
  }

  export type ServiceRatingAvgAggregateOutputType = {
    st: number | null
  }

  export type ServiceRatingSumAggregateOutputType = {
    st: number | null
  }

  export type ServiceRatingMinAggregateOutputType = {
    id: string | null
    serviceId: string | null
    createdAt: Date | null
    userId: string | null
    st: number | null
  }

  export type ServiceRatingMaxAggregateOutputType = {
    id: string | null
    serviceId: string | null
    createdAt: Date | null
    userId: string | null
    st: number | null
  }

  export type ServiceRatingCountAggregateOutputType = {
    id: number
    serviceId: number
    createdAt: number
    userId: number
    st: number
    _all: number
  }


  export type ServiceRatingAvgAggregateInputType = {
    st?: true
  }

  export type ServiceRatingSumAggregateInputType = {
    st?: true
  }

  export type ServiceRatingMinAggregateInputType = {
    id?: true
    serviceId?: true
    createdAt?: true
    userId?: true
    st?: true
  }

  export type ServiceRatingMaxAggregateInputType = {
    id?: true
    serviceId?: true
    createdAt?: true
    userId?: true
    st?: true
  }

  export type ServiceRatingCountAggregateInputType = {
    id?: true
    serviceId?: true
    createdAt?: true
    userId?: true
    st?: true
    _all?: true
  }

  export type ServiceRatingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRating to aggregate.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceRatings
    **/
    _count?: true | ServiceRatingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceRatingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceRatingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceRatingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceRatingMaxAggregateInputType
  }

  export type GetServiceRatingAggregateType<T extends ServiceRatingAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceRating]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceRating[P]>
      : GetScalarType<T[P], AggregateServiceRating[P]>
  }




  export type ServiceRatingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceRatingWhereInput
    orderBy?: ServiceRatingOrderByWithAggregationInput | ServiceRatingOrderByWithAggregationInput[]
    by: ServiceRatingScalarFieldEnum[] | ServiceRatingScalarFieldEnum
    having?: ServiceRatingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceRatingCountAggregateInputType | true
    _avg?: ServiceRatingAvgAggregateInputType
    _sum?: ServiceRatingSumAggregateInputType
    _min?: ServiceRatingMinAggregateInputType
    _max?: ServiceRatingMaxAggregateInputType
  }

  export type ServiceRatingGroupByOutputType = {
    id: string
    serviceId: string | null
    createdAt: Date
    userId: string | null
    st: number | null
    _count: ServiceRatingCountAggregateOutputType | null
    _avg: ServiceRatingAvgAggregateOutputType | null
    _sum: ServiceRatingSumAggregateOutputType | null
    _min: ServiceRatingMinAggregateOutputType | null
    _max: ServiceRatingMaxAggregateOutputType | null
  }

  type GetServiceRatingGroupByPayload<T extends ServiceRatingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceRatingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceRatingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceRatingGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceRatingGroupByOutputType[P]>
        }
      >
    >


  export type ServiceRatingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    serviceId?: boolean
    createdAt?: boolean
    userId?: boolean
    st?: boolean
    service?: boolean | ServiceRating$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["serviceRating"]>



  export type ServiceRatingSelectScalar = {
    id?: boolean
    serviceId?: boolean
    createdAt?: boolean
    userId?: boolean
    st?: boolean
  }

  export type ServiceRatingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "serviceId" | "createdAt" | "userId" | "st", ExtArgs["result"]["serviceRating"]>
  export type ServiceRatingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServiceRating$serviceArgs<ExtArgs>
  }

  export type $ServiceRatingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceRating"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      serviceId: string | null
      createdAt: Date
      userId: string | null
      st: number | null
    }, ExtArgs["result"]["serviceRating"]>
    composites: {}
  }

  type ServiceRatingGetPayload<S extends boolean | null | undefined | ServiceRatingDefaultArgs> = $Result.GetResult<Prisma.$ServiceRatingPayload, S>

  type ServiceRatingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceRatingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceRatingCountAggregateInputType | true
    }

  export interface ServiceRatingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceRating'], meta: { name: 'ServiceRating' } }
    /**
     * Find zero or one ServiceRating that matches the filter.
     * @param {ServiceRatingFindUniqueArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceRatingFindUniqueArgs>(args: SelectSubset<T, ServiceRatingFindUniqueArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceRating that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceRatingFindUniqueOrThrowArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceRatingFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceRatingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRating that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingFindFirstArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceRatingFindFirstArgs>(args?: SelectSubset<T, ServiceRatingFindFirstArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceRating that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingFindFirstOrThrowArgs} args - Arguments to find a ServiceRating
     * @example
     * // Get one ServiceRating
     * const serviceRating = await prisma.serviceRating.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceRatingFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceRatingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRatings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceRatings
     * const serviceRatings = await prisma.serviceRating.findMany()
     * 
     * // Get first 10 ServiceRatings
     * const serviceRatings = await prisma.serviceRating.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceRatingWithIdOnly = await prisma.serviceRating.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceRatingFindManyArgs>(args?: SelectSubset<T, ServiceRatingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceRating.
     * @param {ServiceRatingCreateArgs} args - Arguments to create a ServiceRating.
     * @example
     * // Create one ServiceRating
     * const ServiceRating = await prisma.serviceRating.create({
     *   data: {
     *     // ... data to create a ServiceRating
     *   }
     * })
     * 
     */
    create<T extends ServiceRatingCreateArgs>(args: SelectSubset<T, ServiceRatingCreateArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceRatings.
     * @param {ServiceRatingCreateManyArgs} args - Arguments to create many ServiceRatings.
     * @example
     * // Create many ServiceRatings
     * const serviceRating = await prisma.serviceRating.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceRatingCreateManyArgs>(args?: SelectSubset<T, ServiceRatingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServiceRating.
     * @param {ServiceRatingDeleteArgs} args - Arguments to delete one ServiceRating.
     * @example
     * // Delete one ServiceRating
     * const ServiceRating = await prisma.serviceRating.delete({
     *   where: {
     *     // ... filter to delete one ServiceRating
     *   }
     * })
     * 
     */
    delete<T extends ServiceRatingDeleteArgs>(args: SelectSubset<T, ServiceRatingDeleteArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceRating.
     * @param {ServiceRatingUpdateArgs} args - Arguments to update one ServiceRating.
     * @example
     * // Update one ServiceRating
     * const serviceRating = await prisma.serviceRating.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceRatingUpdateArgs>(args: SelectSubset<T, ServiceRatingUpdateArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceRatings.
     * @param {ServiceRatingDeleteManyArgs} args - Arguments to filter ServiceRatings to delete.
     * @example
     * // Delete a few ServiceRatings
     * const { count } = await prisma.serviceRating.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceRatingDeleteManyArgs>(args?: SelectSubset<T, ServiceRatingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceRatings
     * const serviceRating = await prisma.serviceRating.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceRatingUpdateManyArgs>(args: SelectSubset<T, ServiceRatingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServiceRating.
     * @param {ServiceRatingUpsertArgs} args - Arguments to update or create a ServiceRating.
     * @example
     * // Update or create a ServiceRating
     * const serviceRating = await prisma.serviceRating.upsert({
     *   create: {
     *     // ... data to create a ServiceRating
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceRating we want to update
     *   }
     * })
     */
    upsert<T extends ServiceRatingUpsertArgs>(args: SelectSubset<T, ServiceRatingUpsertArgs<ExtArgs>>): Prisma__ServiceRatingClient<$Result.GetResult<Prisma.$ServiceRatingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceRatings that matches the filter.
     * @param {ServiceRatingFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const serviceRating = await prisma.serviceRating.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServiceRatingFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServiceRating.
     * @param {ServiceRatingAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const serviceRating = await prisma.serviceRating.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServiceRatingAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServiceRatings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingCountArgs} args - Arguments to filter ServiceRatings to count.
     * @example
     * // Count the number of ServiceRatings
     * const count = await prisma.serviceRating.count({
     *   where: {
     *     // ... the filter for the ServiceRatings we want to count
     *   }
     * })
    **/
    count<T extends ServiceRatingCountArgs>(
      args?: Subset<T, ServiceRatingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceRatingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceRatingAggregateArgs>(args: Subset<T, ServiceRatingAggregateArgs>): Prisma.PrismaPromise<GetServiceRatingAggregateType<T>>

    /**
     * Group by ServiceRating.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceRatingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceRatingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceRatingGroupByArgs['orderBy'] }
        : { orderBy?: ServiceRatingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceRatingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceRatingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceRating model
   */
  readonly fields: ServiceRatingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceRating.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceRatingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServiceRating$serviceArgs<ExtArgs> = {}>(args?: Subset<T, ServiceRating$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceRating model
   */
  interface ServiceRatingFieldRefs {
    readonly id: FieldRef<"ServiceRating", 'String'>
    readonly serviceId: FieldRef<"ServiceRating", 'String'>
    readonly createdAt: FieldRef<"ServiceRating", 'DateTime'>
    readonly userId: FieldRef<"ServiceRating", 'String'>
    readonly st: FieldRef<"ServiceRating", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ServiceRating findUnique
   */
  export type ServiceRatingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating findUniqueOrThrow
   */
  export type ServiceRatingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating findFirst
   */
  export type ServiceRatingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRatings.
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRatings.
     */
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRating findFirstOrThrow
   */
  export type ServiceRatingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRating to fetch.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceRatings.
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceRatings.
     */
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRating findMany
   */
  export type ServiceRatingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter, which ServiceRatings to fetch.
     */
    where?: ServiceRatingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceRatings to fetch.
     */
    orderBy?: ServiceRatingOrderByWithRelationInput | ServiceRatingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceRatings.
     */
    cursor?: ServiceRatingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceRatings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceRatings.
     */
    skip?: number
    distinct?: ServiceRatingScalarFieldEnum | ServiceRatingScalarFieldEnum[]
  }

  /**
   * ServiceRating create
   */
  export type ServiceRatingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceRating.
     */
    data?: XOR<ServiceRatingCreateInput, ServiceRatingUncheckedCreateInput>
  }

  /**
   * ServiceRating createMany
   */
  export type ServiceRatingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceRatings.
     */
    data: ServiceRatingCreateManyInput | ServiceRatingCreateManyInput[]
  }

  /**
   * ServiceRating update
   */
  export type ServiceRatingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceRating.
     */
    data: XOR<ServiceRatingUpdateInput, ServiceRatingUncheckedUpdateInput>
    /**
     * Choose, which ServiceRating to update.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating updateMany
   */
  export type ServiceRatingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceRatings.
     */
    data: XOR<ServiceRatingUpdateManyMutationInput, ServiceRatingUncheckedUpdateManyInput>
    /**
     * Filter which ServiceRatings to update
     */
    where?: ServiceRatingWhereInput
    /**
     * Limit how many ServiceRatings to update.
     */
    limit?: number
  }

  /**
   * ServiceRating upsert
   */
  export type ServiceRatingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceRating to update in case it exists.
     */
    where: ServiceRatingWhereUniqueInput
    /**
     * In case the ServiceRating found by the `where` argument doesn't exist, create a new ServiceRating with this data.
     */
    create: XOR<ServiceRatingCreateInput, ServiceRatingUncheckedCreateInput>
    /**
     * In case the ServiceRating was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceRatingUpdateInput, ServiceRatingUncheckedUpdateInput>
  }

  /**
   * ServiceRating delete
   */
  export type ServiceRatingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
    /**
     * Filter which ServiceRating to delete.
     */
    where: ServiceRatingWhereUniqueInput
  }

  /**
   * ServiceRating deleteMany
   */
  export type ServiceRatingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceRatings to delete
     */
    where?: ServiceRatingWhereInput
    /**
     * Limit how many ServiceRatings to delete.
     */
    limit?: number
  }

  /**
   * ServiceRating findRaw
   */
  export type ServiceRatingFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceRating aggregateRaw
   */
  export type ServiceRatingAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServiceRating.service
   */
  export type ServiceRating$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * ServiceRating without action
   */
  export type ServiceRatingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceRating
     */
    select?: ServiceRatingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceRating
     */
    omit?: ServiceRatingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceRatingInclude<ExtArgs> | null
  }


  /**
   * Model ServicePricingRule
   */

  export type AggregateServicePricingRule = {
    _count: ServicePricingRuleCountAggregateOutputType | null
    _avg: ServicePricingRuleAvgAggregateOutputType | null
    _sum: ServicePricingRuleSumAggregateOutputType | null
    _min: ServicePricingRuleMinAggregateOutputType | null
    _max: ServicePricingRuleMaxAggregateOutputType | null
  }

  export type ServicePricingRuleAvgAggregateOutputType = {
    dayOfWeek: number | null
    price: number | null
    priority: number | null
  }

  export type ServicePricingRuleSumAggregateOutputType = {
    dayOfWeek: number | null
    price: number | null
    priority: number | null
  }

  export type ServicePricingRuleMinAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceId: string | null
    variantId: string | null
    staffId: string | null
    pricingType: $Enums.PricingType | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    seasonTag: string | null
    price: number | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ServicePricingRuleMaxAggregateOutputType = {
    id: string | null
    tenantId: string | null
    serviceId: string | null
    variantId: string | null
    staffId: string | null
    pricingType: $Enums.PricingType | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    seasonTag: string | null
    price: number | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date | null
  }

  export type ServicePricingRuleCountAggregateOutputType = {
    id: number
    tenantId: number
    serviceId: number
    variantId: number
    staffId: number
    pricingType: number
    dayOfWeek: number
    startTime: number
    endTime: number
    seasonTag: number
    price: number
    priority: number
    isActive: number
    createdAt: number
    _all: number
  }


  export type ServicePricingRuleAvgAggregateInputType = {
    dayOfWeek?: true
    price?: true
    priority?: true
  }

  export type ServicePricingRuleSumAggregateInputType = {
    dayOfWeek?: true
    price?: true
    priority?: true
  }

  export type ServicePricingRuleMinAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    variantId?: true
    staffId?: true
    pricingType?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    seasonTag?: true
    price?: true
    priority?: true
    isActive?: true
    createdAt?: true
  }

  export type ServicePricingRuleMaxAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    variantId?: true
    staffId?: true
    pricingType?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    seasonTag?: true
    price?: true
    priority?: true
    isActive?: true
    createdAt?: true
  }

  export type ServicePricingRuleCountAggregateInputType = {
    id?: true
    tenantId?: true
    serviceId?: true
    variantId?: true
    staffId?: true
    pricingType?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    seasonTag?: true
    price?: true
    priority?: true
    isActive?: true
    createdAt?: true
    _all?: true
  }

  export type ServicePricingRuleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePricingRule to aggregate.
     */
    where?: ServicePricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricingRules to fetch.
     */
    orderBy?: ServicePricingRuleOrderByWithRelationInput | ServicePricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePricingRules
    **/
    _count?: true | ServicePricingRuleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePricingRuleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePricingRuleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePricingRuleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePricingRuleMaxAggregateInputType
  }

  export type GetServicePricingRuleAggregateType<T extends ServicePricingRuleAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePricingRule]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePricingRule[P]>
      : GetScalarType<T[P], AggregateServicePricingRule[P]>
  }




  export type ServicePricingRuleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePricingRuleWhereInput
    orderBy?: ServicePricingRuleOrderByWithAggregationInput | ServicePricingRuleOrderByWithAggregationInput[]
    by: ServicePricingRuleScalarFieldEnum[] | ServicePricingRuleScalarFieldEnum
    having?: ServicePricingRuleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePricingRuleCountAggregateInputType | true
    _avg?: ServicePricingRuleAvgAggregateInputType
    _sum?: ServicePricingRuleSumAggregateInputType
    _min?: ServicePricingRuleMinAggregateInputType
    _max?: ServicePricingRuleMaxAggregateInputType
  }

  export type ServicePricingRuleGroupByOutputType = {
    id: string
    tenantId: string | null
    serviceId: string | null
    variantId: string | null
    staffId: string | null
    pricingType: $Enums.PricingType
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    seasonTag: string | null
    price: number | null
    priority: number | null
    isActive: boolean | null
    createdAt: Date
    _count: ServicePricingRuleCountAggregateOutputType | null
    _avg: ServicePricingRuleAvgAggregateOutputType | null
    _sum: ServicePricingRuleSumAggregateOutputType | null
    _min: ServicePricingRuleMinAggregateOutputType | null
    _max: ServicePricingRuleMaxAggregateOutputType | null
  }

  type GetServicePricingRuleGroupByPayload<T extends ServicePricingRuleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePricingRuleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePricingRuleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePricingRuleGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePricingRuleGroupByOutputType[P]>
        }
      >
    >


  export type ServicePricingRuleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    variantId?: boolean
    staffId?: boolean
    pricingType?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    seasonTag?: boolean
    price?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
    service?: boolean | ServicePricingRule$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["servicePricingRule"]>



  export type ServicePricingRuleSelectScalar = {
    id?: boolean
    tenantId?: boolean
    serviceId?: boolean
    variantId?: boolean
    staffId?: boolean
    pricingType?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    seasonTag?: boolean
    price?: boolean
    priority?: boolean
    isActive?: boolean
    createdAt?: boolean
  }

  export type ServicePricingRuleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tenantId" | "serviceId" | "variantId" | "staffId" | "pricingType" | "dayOfWeek" | "startTime" | "endTime" | "seasonTag" | "price" | "priority" | "isActive" | "createdAt", ExtArgs["result"]["servicePricingRule"]>
  export type ServicePricingRuleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    service?: boolean | ServicePricingRule$serviceArgs<ExtArgs>
  }

  export type $ServicePricingRulePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePricingRule"
    objects: {
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tenantId: string | null
      serviceId: string | null
      variantId: string | null
      staffId: string | null
      pricingType: $Enums.PricingType
      dayOfWeek: number | null
      startTime: string | null
      endTime: string | null
      seasonTag: string | null
      price: number | null
      priority: number | null
      isActive: boolean | null
      createdAt: Date
    }, ExtArgs["result"]["servicePricingRule"]>
    composites: {}
  }

  type ServicePricingRuleGetPayload<S extends boolean | null | undefined | ServicePricingRuleDefaultArgs> = $Result.GetResult<Prisma.$ServicePricingRulePayload, S>

  type ServicePricingRuleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicePricingRuleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicePricingRuleCountAggregateInputType | true
    }

  export interface ServicePricingRuleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePricingRule'], meta: { name: 'ServicePricingRule' } }
    /**
     * Find zero or one ServicePricingRule that matches the filter.
     * @param {ServicePricingRuleFindUniqueArgs} args - Arguments to find a ServicePricingRule
     * @example
     * // Get one ServicePricingRule
     * const servicePricingRule = await prisma.servicePricingRule.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePricingRuleFindUniqueArgs>(args: SelectSubset<T, ServicePricingRuleFindUniqueArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicePricingRule that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicePricingRuleFindUniqueOrThrowArgs} args - Arguments to find a ServicePricingRule
     * @example
     * // Get one ServicePricingRule
     * const servicePricingRule = await prisma.servicePricingRule.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePricingRuleFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePricingRuleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePricingRule that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleFindFirstArgs} args - Arguments to find a ServicePricingRule
     * @example
     * // Get one ServicePricingRule
     * const servicePricingRule = await prisma.servicePricingRule.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePricingRuleFindFirstArgs>(args?: SelectSubset<T, ServicePricingRuleFindFirstArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePricingRule that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleFindFirstOrThrowArgs} args - Arguments to find a ServicePricingRule
     * @example
     * // Get one ServicePricingRule
     * const servicePricingRule = await prisma.servicePricingRule.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePricingRuleFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePricingRuleFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicePricingRules that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePricingRules
     * const servicePricingRules = await prisma.servicePricingRule.findMany()
     * 
     * // Get first 10 ServicePricingRules
     * const servicePricingRules = await prisma.servicePricingRule.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePricingRuleWithIdOnly = await prisma.servicePricingRule.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePricingRuleFindManyArgs>(args?: SelectSubset<T, ServicePricingRuleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicePricingRule.
     * @param {ServicePricingRuleCreateArgs} args - Arguments to create a ServicePricingRule.
     * @example
     * // Create one ServicePricingRule
     * const ServicePricingRule = await prisma.servicePricingRule.create({
     *   data: {
     *     // ... data to create a ServicePricingRule
     *   }
     * })
     * 
     */
    create<T extends ServicePricingRuleCreateArgs>(args: SelectSubset<T, ServicePricingRuleCreateArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicePricingRules.
     * @param {ServicePricingRuleCreateManyArgs} args - Arguments to create many ServicePricingRules.
     * @example
     * // Create many ServicePricingRules
     * const servicePricingRule = await prisma.servicePricingRule.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePricingRuleCreateManyArgs>(args?: SelectSubset<T, ServicePricingRuleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ServicePricingRule.
     * @param {ServicePricingRuleDeleteArgs} args - Arguments to delete one ServicePricingRule.
     * @example
     * // Delete one ServicePricingRule
     * const ServicePricingRule = await prisma.servicePricingRule.delete({
     *   where: {
     *     // ... filter to delete one ServicePricingRule
     *   }
     * })
     * 
     */
    delete<T extends ServicePricingRuleDeleteArgs>(args: SelectSubset<T, ServicePricingRuleDeleteArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicePricingRule.
     * @param {ServicePricingRuleUpdateArgs} args - Arguments to update one ServicePricingRule.
     * @example
     * // Update one ServicePricingRule
     * const servicePricingRule = await prisma.servicePricingRule.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePricingRuleUpdateArgs>(args: SelectSubset<T, ServicePricingRuleUpdateArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicePricingRules.
     * @param {ServicePricingRuleDeleteManyArgs} args - Arguments to filter ServicePricingRules to delete.
     * @example
     * // Delete a few ServicePricingRules
     * const { count } = await prisma.servicePricingRule.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePricingRuleDeleteManyArgs>(args?: SelectSubset<T, ServicePricingRuleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePricingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePricingRules
     * const servicePricingRule = await prisma.servicePricingRule.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePricingRuleUpdateManyArgs>(args: SelectSubset<T, ServicePricingRuleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ServicePricingRule.
     * @param {ServicePricingRuleUpsertArgs} args - Arguments to update or create a ServicePricingRule.
     * @example
     * // Update or create a ServicePricingRule
     * const servicePricingRule = await prisma.servicePricingRule.upsert({
     *   create: {
     *     // ... data to create a ServicePricingRule
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePricingRule we want to update
     *   }
     * })
     */
    upsert<T extends ServicePricingRuleUpsertArgs>(args: SelectSubset<T, ServicePricingRuleUpsertArgs<ExtArgs>>): Prisma__ServicePricingRuleClient<$Result.GetResult<Prisma.$ServicePricingRulePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicePricingRules that matches the filter.
     * @param {ServicePricingRuleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const servicePricingRule = await prisma.servicePricingRule.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: ServicePricingRuleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a ServicePricingRule.
     * @param {ServicePricingRuleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const servicePricingRule = await prisma.servicePricingRule.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: ServicePricingRuleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of ServicePricingRules.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleCountArgs} args - Arguments to filter ServicePricingRules to count.
     * @example
     * // Count the number of ServicePricingRules
     * const count = await prisma.servicePricingRule.count({
     *   where: {
     *     // ... the filter for the ServicePricingRules we want to count
     *   }
     * })
    **/
    count<T extends ServicePricingRuleCountArgs>(
      args?: Subset<T, ServicePricingRuleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePricingRuleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePricingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePricingRuleAggregateArgs>(args: Subset<T, ServicePricingRuleAggregateArgs>): Prisma.PrismaPromise<GetServicePricingRuleAggregateType<T>>

    /**
     * Group by ServicePricingRule.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePricingRuleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePricingRuleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePricingRuleGroupByArgs['orderBy'] }
        : { orderBy?: ServicePricingRuleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePricingRuleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePricingRuleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePricingRule model
   */
  readonly fields: ServicePricingRuleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePricingRule.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePricingRuleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    service<T extends ServicePricingRule$serviceArgs<ExtArgs> = {}>(args?: Subset<T, ServicePricingRule$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePricingRule model
   */
  interface ServicePricingRuleFieldRefs {
    readonly id: FieldRef<"ServicePricingRule", 'String'>
    readonly tenantId: FieldRef<"ServicePricingRule", 'String'>
    readonly serviceId: FieldRef<"ServicePricingRule", 'String'>
    readonly variantId: FieldRef<"ServicePricingRule", 'String'>
    readonly staffId: FieldRef<"ServicePricingRule", 'String'>
    readonly pricingType: FieldRef<"ServicePricingRule", 'PricingType'>
    readonly dayOfWeek: FieldRef<"ServicePricingRule", 'Int'>
    readonly startTime: FieldRef<"ServicePricingRule", 'String'>
    readonly endTime: FieldRef<"ServicePricingRule", 'String'>
    readonly seasonTag: FieldRef<"ServicePricingRule", 'String'>
    readonly price: FieldRef<"ServicePricingRule", 'Int'>
    readonly priority: FieldRef<"ServicePricingRule", 'Int'>
    readonly isActive: FieldRef<"ServicePricingRule", 'Boolean'>
    readonly createdAt: FieldRef<"ServicePricingRule", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePricingRule findUnique
   */
  export type ServicePricingRuleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricingRule to fetch.
     */
    where: ServicePricingRuleWhereUniqueInput
  }

  /**
   * ServicePricingRule findUniqueOrThrow
   */
  export type ServicePricingRuleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricingRule to fetch.
     */
    where: ServicePricingRuleWhereUniqueInput
  }

  /**
   * ServicePricingRule findFirst
   */
  export type ServicePricingRuleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricingRule to fetch.
     */
    where?: ServicePricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricingRules to fetch.
     */
    orderBy?: ServicePricingRuleOrderByWithRelationInput | ServicePricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePricingRules.
     */
    cursor?: ServicePricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePricingRules.
     */
    distinct?: ServicePricingRuleScalarFieldEnum | ServicePricingRuleScalarFieldEnum[]
  }

  /**
   * ServicePricingRule findFirstOrThrow
   */
  export type ServicePricingRuleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricingRule to fetch.
     */
    where?: ServicePricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricingRules to fetch.
     */
    orderBy?: ServicePricingRuleOrderByWithRelationInput | ServicePricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePricingRules.
     */
    cursor?: ServicePricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricingRules.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePricingRules.
     */
    distinct?: ServicePricingRuleScalarFieldEnum | ServicePricingRuleScalarFieldEnum[]
  }

  /**
   * ServicePricingRule findMany
   */
  export type ServicePricingRuleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * Filter, which ServicePricingRules to fetch.
     */
    where?: ServicePricingRuleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePricingRules to fetch.
     */
    orderBy?: ServicePricingRuleOrderByWithRelationInput | ServicePricingRuleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePricingRules.
     */
    cursor?: ServicePricingRuleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePricingRules from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePricingRules.
     */
    skip?: number
    distinct?: ServicePricingRuleScalarFieldEnum | ServicePricingRuleScalarFieldEnum[]
  }

  /**
   * ServicePricingRule create
   */
  export type ServicePricingRuleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePricingRule.
     */
    data: XOR<ServicePricingRuleCreateInput, ServicePricingRuleUncheckedCreateInput>
  }

  /**
   * ServicePricingRule createMany
   */
  export type ServicePricingRuleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePricingRules.
     */
    data: ServicePricingRuleCreateManyInput | ServicePricingRuleCreateManyInput[]
  }

  /**
   * ServicePricingRule update
   */
  export type ServicePricingRuleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePricingRule.
     */
    data: XOR<ServicePricingRuleUpdateInput, ServicePricingRuleUncheckedUpdateInput>
    /**
     * Choose, which ServicePricingRule to update.
     */
    where: ServicePricingRuleWhereUniqueInput
  }

  /**
   * ServicePricingRule updateMany
   */
  export type ServicePricingRuleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePricingRules.
     */
    data: XOR<ServicePricingRuleUpdateManyMutationInput, ServicePricingRuleUncheckedUpdateManyInput>
    /**
     * Filter which ServicePricingRules to update
     */
    where?: ServicePricingRuleWhereInput
    /**
     * Limit how many ServicePricingRules to update.
     */
    limit?: number
  }

  /**
   * ServicePricingRule upsert
   */
  export type ServicePricingRuleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePricingRule to update in case it exists.
     */
    where: ServicePricingRuleWhereUniqueInput
    /**
     * In case the ServicePricingRule found by the `where` argument doesn't exist, create a new ServicePricingRule with this data.
     */
    create: XOR<ServicePricingRuleCreateInput, ServicePricingRuleUncheckedCreateInput>
    /**
     * In case the ServicePricingRule was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePricingRuleUpdateInput, ServicePricingRuleUncheckedUpdateInput>
  }

  /**
   * ServicePricingRule delete
   */
  export type ServicePricingRuleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
    /**
     * Filter which ServicePricingRule to delete.
     */
    where: ServicePricingRuleWhereUniqueInput
  }

  /**
   * ServicePricingRule deleteMany
   */
  export type ServicePricingRuleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePricingRules to delete
     */
    where?: ServicePricingRuleWhereInput
    /**
     * Limit how many ServicePricingRules to delete.
     */
    limit?: number
  }

  /**
   * ServicePricingRule findRaw
   */
  export type ServicePricingRuleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServicePricingRule aggregateRaw
   */
  export type ServicePricingRuleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * ServicePricingRule.service
   */
  export type ServicePricingRule$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * ServicePricingRule without action
   */
  export type ServicePricingRuleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePricingRule
     */
    select?: ServicePricingRuleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePricingRule
     */
    omit?: ServicePricingRuleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePricingRuleInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TenantScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TenantScalarFieldEnum = (typeof TenantScalarFieldEnum)[keyof typeof TenantScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    userName: 'userName',
    phonenumber: 'phonenumber',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const SellerScalarFieldEnum: {
    id: 'id',
    storeName: 'storeName'
  };

  export type SellerScalarFieldEnum = (typeof SellerScalarFieldEnum)[keyof typeof SellerScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    userId: 'userId',
    sellerId: 'sellerId',
    code: 'code',
    title: 'title',
    description: 'description',
    slug: 'slug',
    tags: 'tags',
    pricingType: 'pricingType',
    currency: 'currency',
    displayPrice: 'displayPrice',
    taxIncluded: 'taxIncluded',
    taxRateBps: 'taxRateBps',
    durationMin: 'durationMin',
    bufferBeforeMin: 'bufferBeforeMin',
    bufferAfterMin: 'bufferAfterMin',
    minStaffCount: 'minStaffCount',
    maxStaffCount: 'maxStaffCount',
    isBookable: 'isBookable',
    requiresDeposit: 'requiresDeposit',
    depositAmount: 'depositAmount',
    featured: 'featured',
    badge: 'badge',
    highlightColor: 'highlightColor',
    displayOrder: 'displayOrder',
    isActive: 'isActive',
    metaTitle: 'metaTitle',
    metaDescription: 'metaDescription',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const ServiceMediaScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    serviceId: 'serviceId',
    url: 'url',
    alt: 'alt',
    order: 'order',
    createdAt: 'createdAt'
  };

  export type ServiceMediaScalarFieldEnum = (typeof ServiceMediaScalarFieldEnum)[keyof typeof ServiceMediaScalarFieldEnum]


  export const ServiceEvaluationScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    userId: 'userId',
    evaluationContent: 'evaluationContent'
  };

  export type ServiceEvaluationScalarFieldEnum = (typeof ServiceEvaluationScalarFieldEnum)[keyof typeof ServiceEvaluationScalarFieldEnum]


  export const ServiceRatingScalarFieldEnum: {
    id: 'id',
    serviceId: 'serviceId',
    createdAt: 'createdAt',
    userId: 'userId',
    st: 'st'
  };

  export type ServiceRatingScalarFieldEnum = (typeof ServiceRatingScalarFieldEnum)[keyof typeof ServiceRatingScalarFieldEnum]


  export const ServicePricingRuleScalarFieldEnum: {
    id: 'id',
    tenantId: 'tenantId',
    serviceId: 'serviceId',
    variantId: 'variantId',
    staffId: 'staffId',
    pricingType: 'pricingType',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    seasonTag: 'seasonTag',
    price: 'price',
    priority: 'priority',
    isActive: 'isActive',
    createdAt: 'createdAt'
  };

  export type ServicePricingRuleScalarFieldEnum = (typeof ServicePricingRuleScalarFieldEnum)[keyof typeof ServicePricingRuleScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'PricingType'
   */
  export type EnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType'>
    


  /**
   * Reference to a field of type 'PricingType[]'
   */
  export type ListEnumPricingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PricingType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type TenantWhereInput = {
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    id?: StringFilter<"Tenant"> | string
    name?: StringFilter<"Tenant"> | string
    slug?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    services?: ServiceListRelationFilter
  }

  export type TenantOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type TenantWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: TenantWhereInput | TenantWhereInput[]
    OR?: TenantWhereInput[]
    NOT?: TenantWhereInput | TenantWhereInput[]
    name?: StringFilter<"Tenant"> | string
    createdAt?: DateTimeFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeFilter<"Tenant"> | Date | string
    services?: ServiceListRelationFilter
  }, "id" | "slug">

  export type TenantOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TenantCountOrderByAggregateInput
    _max?: TenantMaxOrderByAggregateInput
    _min?: TenantMinOrderByAggregateInput
  }

  export type TenantScalarWhereWithAggregatesInput = {
    AND?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    OR?: TenantScalarWhereWithAggregatesInput[]
    NOT?: TenantScalarWhereWithAggregatesInput | TenantScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Tenant"> | string
    name?: StringWithAggregatesFilter<"Tenant"> | string
    slug?: StringWithAggregatesFilter<"Tenant"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Tenant"> | Date | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    userName?: StringNullableFilter<"User"> | string | null
    phonenumber?: StringNullableFilter<"User"> | string | null
    accessToken?: StringNullableFilter<"User"> | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    services?: ServiceListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    phonenumber?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    userName?: StringNullableFilter<"User"> | string | null
    phonenumber?: StringNullableFilter<"User"> | string | null
    accessToken?: StringNullableFilter<"User"> | string | null
    refreshToken?: StringNullableFilter<"User"> | string | null
    services?: ServiceListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    phonenumber?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    userName?: StringNullableWithAggregatesFilter<"User"> | string | null
    phonenumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"User"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"User"> | string | null
  }

  export type SellerWhereInput = {
    AND?: SellerWhereInput | SellerWhereInput[]
    OR?: SellerWhereInput[]
    NOT?: SellerWhereInput | SellerWhereInput[]
    id?: StringFilter<"Seller"> | string
    storeName?: StringFilter<"Seller"> | string
    services?: ServiceListRelationFilter
  }

  export type SellerOrderByWithRelationInput = {
    id?: SortOrder
    storeName?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
  }

  export type SellerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SellerWhereInput | SellerWhereInput[]
    OR?: SellerWhereInput[]
    NOT?: SellerWhereInput | SellerWhereInput[]
    storeName?: StringFilter<"Seller"> | string
    services?: ServiceListRelationFilter
  }, "id">

  export type SellerOrderByWithAggregationInput = {
    id?: SortOrder
    storeName?: SortOrder
    _count?: SellerCountOrderByAggregateInput
    _max?: SellerMaxOrderByAggregateInput
    _min?: SellerMinOrderByAggregateInput
  }

  export type SellerScalarWhereWithAggregatesInput = {
    AND?: SellerScalarWhereWithAggregatesInput | SellerScalarWhereWithAggregatesInput[]
    OR?: SellerScalarWhereWithAggregatesInput[]
    NOT?: SellerScalarWhereWithAggregatesInput | SellerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Seller"> | string
    storeName?: StringWithAggregatesFilter<"Seller"> | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    tenantId?: StringNullableFilter<"Service"> | string | null
    userId?: StringNullableFilter<"Service"> | string | null
    sellerId?: StringNullableFilter<"Service"> | string | null
    code?: StringNullableFilter<"Service"> | string | null
    title?: StringNullableFilter<"Service"> | string | null
    description?: StringNullableFilter<"Service"> | string | null
    slug?: StringNullableFilter<"Service"> | string | null
    tags?: StringNullableListFilter<"Service">
    pricingType?: EnumPricingTypeNullableFilter<"Service"> | $Enums.PricingType | null
    currency?: StringNullableFilter<"Service"> | string | null
    displayPrice?: BoolNullableFilter<"Service"> | boolean | null
    taxIncluded?: BoolNullableFilter<"Service"> | boolean | null
    taxRateBps?: IntNullableFilter<"Service"> | number | null
    durationMin?: IntNullableFilter<"Service"> | number | null
    bufferBeforeMin?: IntNullableFilter<"Service"> | number | null
    bufferAfterMin?: IntNullableFilter<"Service"> | number | null
    minStaffCount?: IntNullableFilter<"Service"> | number | null
    maxStaffCount?: IntNullableFilter<"Service"> | number | null
    isBookable?: BoolNullableFilter<"Service"> | boolean | null
    requiresDeposit?: BoolNullableFilter<"Service"> | boolean | null
    depositAmount?: IntNullableFilter<"Service"> | number | null
    featured?: BoolNullableFilter<"Service"> | boolean | null
    badge?: StringNullableFilter<"Service"> | string | null
    highlightColor?: StringNullableFilter<"Service"> | string | null
    displayOrder?: IntNullableFilter<"Service"> | number | null
    isActive?: BoolNullableFilter<"Service"> | boolean | null
    metaTitle?: StringNullableFilter<"Service"> | string | null
    metaDescription?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    seller?: XOR<SellerNullableScalarRelationFilter, SellerWhereInput> | null
    pricingRules?: ServicePricingRuleListRelationFilter
    medias?: ServiceMediaListRelationFilter
    evaluation?: ServiceEvaluationListRelationFilter
    rating?: ServiceRatingListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    tags?: SortOrder
    pricingType?: SortOrder
    currency?: SortOrder
    displayPrice?: SortOrder
    taxIncluded?: SortOrder
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    isBookable?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    featured?: SortOrder
    badge?: SortOrder
    highlightColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    tenant?: TenantOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    seller?: SellerOrderByWithRelationInput
    pricingRules?: ServicePricingRuleOrderByRelationAggregateInput
    medias?: ServiceMediaOrderByRelationAggregateInput
    evaluation?: ServiceEvaluationOrderByRelationAggregateInput
    rating?: ServiceRatingOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tenantId_code?: ServiceTenantIdCodeCompoundUniqueInput
    tenantId_slug?: ServiceTenantIdSlugCompoundUniqueInput
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    tenantId?: StringNullableFilter<"Service"> | string | null
    userId?: StringNullableFilter<"Service"> | string | null
    sellerId?: StringNullableFilter<"Service"> | string | null
    code?: StringNullableFilter<"Service"> | string | null
    title?: StringNullableFilter<"Service"> | string | null
    description?: StringNullableFilter<"Service"> | string | null
    slug?: StringNullableFilter<"Service"> | string | null
    tags?: StringNullableListFilter<"Service">
    pricingType?: EnumPricingTypeNullableFilter<"Service"> | $Enums.PricingType | null
    currency?: StringNullableFilter<"Service"> | string | null
    displayPrice?: BoolNullableFilter<"Service"> | boolean | null
    taxIncluded?: BoolNullableFilter<"Service"> | boolean | null
    taxRateBps?: IntNullableFilter<"Service"> | number | null
    durationMin?: IntNullableFilter<"Service"> | number | null
    bufferBeforeMin?: IntNullableFilter<"Service"> | number | null
    bufferAfterMin?: IntNullableFilter<"Service"> | number | null
    minStaffCount?: IntNullableFilter<"Service"> | number | null
    maxStaffCount?: IntNullableFilter<"Service"> | number | null
    isBookable?: BoolNullableFilter<"Service"> | boolean | null
    requiresDeposit?: BoolNullableFilter<"Service"> | boolean | null
    depositAmount?: IntNullableFilter<"Service"> | number | null
    featured?: BoolNullableFilter<"Service"> | boolean | null
    badge?: StringNullableFilter<"Service"> | string | null
    highlightColor?: StringNullableFilter<"Service"> | string | null
    displayOrder?: IntNullableFilter<"Service"> | number | null
    isActive?: BoolNullableFilter<"Service"> | boolean | null
    metaTitle?: StringNullableFilter<"Service"> | string | null
    metaDescription?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    tenant?: XOR<TenantNullableScalarRelationFilter, TenantWhereInput> | null
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    seller?: XOR<SellerNullableScalarRelationFilter, SellerWhereInput> | null
    pricingRules?: ServicePricingRuleListRelationFilter
    medias?: ServiceMediaListRelationFilter
    evaluation?: ServiceEvaluationListRelationFilter
    rating?: ServiceRatingListRelationFilter
  }, "id" | "tenantId_code" | "tenantId_slug">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    tags?: SortOrder
    pricingType?: SortOrder
    currency?: SortOrder
    displayPrice?: SortOrder
    taxIncluded?: SortOrder
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    isBookable?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    featured?: SortOrder
    badge?: SortOrder
    highlightColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    tenantId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    userId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    sellerId?: StringNullableWithAggregatesFilter<"Service"> | string | null
    code?: StringNullableWithAggregatesFilter<"Service"> | string | null
    title?: StringNullableWithAggregatesFilter<"Service"> | string | null
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    slug?: StringNullableWithAggregatesFilter<"Service"> | string | null
    tags?: StringNullableListFilter<"Service">
    pricingType?: EnumPricingTypeNullableWithAggregatesFilter<"Service"> | $Enums.PricingType | null
    currency?: StringNullableWithAggregatesFilter<"Service"> | string | null
    displayPrice?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    taxIncluded?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    taxRateBps?: IntNullableWithAggregatesFilter<"Service"> | number | null
    durationMin?: IntNullableWithAggregatesFilter<"Service"> | number | null
    bufferBeforeMin?: IntNullableWithAggregatesFilter<"Service"> | number | null
    bufferAfterMin?: IntNullableWithAggregatesFilter<"Service"> | number | null
    minStaffCount?: IntNullableWithAggregatesFilter<"Service"> | number | null
    maxStaffCount?: IntNullableWithAggregatesFilter<"Service"> | number | null
    isBookable?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    requiresDeposit?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    depositAmount?: IntNullableWithAggregatesFilter<"Service"> | number | null
    featured?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    badge?: StringNullableWithAggregatesFilter<"Service"> | string | null
    highlightColor?: StringNullableWithAggregatesFilter<"Service"> | string | null
    displayOrder?: IntNullableWithAggregatesFilter<"Service"> | number | null
    isActive?: BoolNullableWithAggregatesFilter<"Service"> | boolean | null
    metaTitle?: StringNullableWithAggregatesFilter<"Service"> | string | null
    metaDescription?: StringNullableWithAggregatesFilter<"Service"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type ServiceMediaWhereInput = {
    AND?: ServiceMediaWhereInput | ServiceMediaWhereInput[]
    OR?: ServiceMediaWhereInput[]
    NOT?: ServiceMediaWhereInput | ServiceMediaWhereInput[]
    id?: StringFilter<"ServiceMedia"> | string
    tenantId?: StringNullableFilter<"ServiceMedia"> | string | null
    serviceId?: StringNullableFilter<"ServiceMedia"> | string | null
    url?: StringNullableFilter<"ServiceMedia"> | string | null
    alt?: StringNullableFilter<"ServiceMedia"> | string | null
    order?: IntFilter<"ServiceMedia"> | number
    createdAt?: DateTimeFilter<"ServiceMedia"> | Date | string
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ServiceMediaOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceMediaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceMediaWhereInput | ServiceMediaWhereInput[]
    OR?: ServiceMediaWhereInput[]
    NOT?: ServiceMediaWhereInput | ServiceMediaWhereInput[]
    tenantId?: StringNullableFilter<"ServiceMedia"> | string | null
    serviceId?: StringNullableFilter<"ServiceMedia"> | string | null
    url?: StringNullableFilter<"ServiceMedia"> | string | null
    alt?: StringNullableFilter<"ServiceMedia"> | string | null
    order?: IntFilter<"ServiceMedia"> | number
    createdAt?: DateTimeFilter<"ServiceMedia"> | Date | string
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type ServiceMediaOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
    _count?: ServiceMediaCountOrderByAggregateInput
    _avg?: ServiceMediaAvgOrderByAggregateInput
    _max?: ServiceMediaMaxOrderByAggregateInput
    _min?: ServiceMediaMinOrderByAggregateInput
    _sum?: ServiceMediaSumOrderByAggregateInput
  }

  export type ServiceMediaScalarWhereWithAggregatesInput = {
    AND?: ServiceMediaScalarWhereWithAggregatesInput | ServiceMediaScalarWhereWithAggregatesInput[]
    OR?: ServiceMediaScalarWhereWithAggregatesInput[]
    NOT?: ServiceMediaScalarWhereWithAggregatesInput | ServiceMediaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceMedia"> | string
    tenantId?: StringNullableWithAggregatesFilter<"ServiceMedia"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"ServiceMedia"> | string | null
    url?: StringNullableWithAggregatesFilter<"ServiceMedia"> | string | null
    alt?: StringNullableWithAggregatesFilter<"ServiceMedia"> | string | null
    order?: IntWithAggregatesFilter<"ServiceMedia"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ServiceMedia"> | Date | string
  }

  export type ServiceEvaluationWhereInput = {
    AND?: ServiceEvaluationWhereInput | ServiceEvaluationWhereInput[]
    OR?: ServiceEvaluationWhereInput[]
    NOT?: ServiceEvaluationWhereInput | ServiceEvaluationWhereInput[]
    id?: StringFilter<"ServiceEvaluation"> | string
    serviceId?: StringNullableFilter<"ServiceEvaluation"> | string | null
    createdAt?: DateTimeFilter<"ServiceEvaluation"> | Date | string
    userId?: StringNullableFilter<"ServiceEvaluation"> | string | null
    evaluationContent?: StringNullableFilter<"ServiceEvaluation"> | string | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ServiceEvaluationOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    evaluationContent?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceEvaluationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceEvaluationWhereInput | ServiceEvaluationWhereInput[]
    OR?: ServiceEvaluationWhereInput[]
    NOT?: ServiceEvaluationWhereInput | ServiceEvaluationWhereInput[]
    serviceId?: StringNullableFilter<"ServiceEvaluation"> | string | null
    createdAt?: DateTimeFilter<"ServiceEvaluation"> | Date | string
    userId?: StringNullableFilter<"ServiceEvaluation"> | string | null
    evaluationContent?: StringNullableFilter<"ServiceEvaluation"> | string | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type ServiceEvaluationOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    evaluationContent?: SortOrder
    _count?: ServiceEvaluationCountOrderByAggregateInput
    _max?: ServiceEvaluationMaxOrderByAggregateInput
    _min?: ServiceEvaluationMinOrderByAggregateInput
  }

  export type ServiceEvaluationScalarWhereWithAggregatesInput = {
    AND?: ServiceEvaluationScalarWhereWithAggregatesInput | ServiceEvaluationScalarWhereWithAggregatesInput[]
    OR?: ServiceEvaluationScalarWhereWithAggregatesInput[]
    NOT?: ServiceEvaluationScalarWhereWithAggregatesInput | ServiceEvaluationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceEvaluation"> | string
    serviceId?: StringNullableWithAggregatesFilter<"ServiceEvaluation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceEvaluation"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"ServiceEvaluation"> | string | null
    evaluationContent?: StringNullableWithAggregatesFilter<"ServiceEvaluation"> | string | null
  }

  export type ServiceRatingWhereInput = {
    AND?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    OR?: ServiceRatingWhereInput[]
    NOT?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    id?: StringFilter<"ServiceRating"> | string
    serviceId?: StringNullableFilter<"ServiceRating"> | string | null
    createdAt?: DateTimeFilter<"ServiceRating"> | Date | string
    userId?: StringNullableFilter<"ServiceRating"> | string | null
    st?: IntNullableFilter<"ServiceRating"> | number | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ServiceRatingOrderByWithRelationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    st?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServiceRatingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    OR?: ServiceRatingWhereInput[]
    NOT?: ServiceRatingWhereInput | ServiceRatingWhereInput[]
    serviceId?: StringNullableFilter<"ServiceRating"> | string | null
    createdAt?: DateTimeFilter<"ServiceRating"> | Date | string
    userId?: StringNullableFilter<"ServiceRating"> | string | null
    st?: IntNullableFilter<"ServiceRating"> | number | null
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type ServiceRatingOrderByWithAggregationInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    st?: SortOrder
    _count?: ServiceRatingCountOrderByAggregateInput
    _avg?: ServiceRatingAvgOrderByAggregateInput
    _max?: ServiceRatingMaxOrderByAggregateInput
    _min?: ServiceRatingMinOrderByAggregateInput
    _sum?: ServiceRatingSumOrderByAggregateInput
  }

  export type ServiceRatingScalarWhereWithAggregatesInput = {
    AND?: ServiceRatingScalarWhereWithAggregatesInput | ServiceRatingScalarWhereWithAggregatesInput[]
    OR?: ServiceRatingScalarWhereWithAggregatesInput[]
    NOT?: ServiceRatingScalarWhereWithAggregatesInput | ServiceRatingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceRating"> | string
    serviceId?: StringNullableWithAggregatesFilter<"ServiceRating"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ServiceRating"> | Date | string
    userId?: StringNullableWithAggregatesFilter<"ServiceRating"> | string | null
    st?: IntNullableWithAggregatesFilter<"ServiceRating"> | number | null
  }

  export type ServicePricingRuleWhereInput = {
    AND?: ServicePricingRuleWhereInput | ServicePricingRuleWhereInput[]
    OR?: ServicePricingRuleWhereInput[]
    NOT?: ServicePricingRuleWhereInput | ServicePricingRuleWhereInput[]
    id?: StringFilter<"ServicePricingRule"> | string
    tenantId?: StringNullableFilter<"ServicePricingRule"> | string | null
    serviceId?: StringNullableFilter<"ServicePricingRule"> | string | null
    variantId?: StringNullableFilter<"ServicePricingRule"> | string | null
    staffId?: StringNullableFilter<"ServicePricingRule"> | string | null
    pricingType?: EnumPricingTypeFilter<"ServicePricingRule"> | $Enums.PricingType
    dayOfWeek?: IntNullableFilter<"ServicePricingRule"> | number | null
    startTime?: StringNullableFilter<"ServicePricingRule"> | string | null
    endTime?: StringNullableFilter<"ServicePricingRule"> | string | null
    seasonTag?: StringNullableFilter<"ServicePricingRule"> | string | null
    price?: IntNullableFilter<"ServicePricingRule"> | number | null
    priority?: IntNullableFilter<"ServicePricingRule"> | number | null
    isActive?: BoolNullableFilter<"ServicePricingRule"> | boolean | null
    createdAt?: DateTimeFilter<"ServicePricingRule"> | Date | string
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ServicePricingRuleOrderByWithRelationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    variantId?: SortOrder
    staffId?: SortOrder
    pricingType?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    seasonTag?: SortOrder
    price?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    service?: ServiceOrderByWithRelationInput
  }

  export type ServicePricingRuleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicePricingRuleWhereInput | ServicePricingRuleWhereInput[]
    OR?: ServicePricingRuleWhereInput[]
    NOT?: ServicePricingRuleWhereInput | ServicePricingRuleWhereInput[]
    tenantId?: StringNullableFilter<"ServicePricingRule"> | string | null
    serviceId?: StringNullableFilter<"ServicePricingRule"> | string | null
    variantId?: StringNullableFilter<"ServicePricingRule"> | string | null
    staffId?: StringNullableFilter<"ServicePricingRule"> | string | null
    pricingType?: EnumPricingTypeFilter<"ServicePricingRule"> | $Enums.PricingType
    dayOfWeek?: IntNullableFilter<"ServicePricingRule"> | number | null
    startTime?: StringNullableFilter<"ServicePricingRule"> | string | null
    endTime?: StringNullableFilter<"ServicePricingRule"> | string | null
    seasonTag?: StringNullableFilter<"ServicePricingRule"> | string | null
    price?: IntNullableFilter<"ServicePricingRule"> | number | null
    priority?: IntNullableFilter<"ServicePricingRule"> | number | null
    isActive?: BoolNullableFilter<"ServicePricingRule"> | boolean | null
    createdAt?: DateTimeFilter<"ServicePricingRule"> | Date | string
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type ServicePricingRuleOrderByWithAggregationInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    variantId?: SortOrder
    staffId?: SortOrder
    pricingType?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    seasonTag?: SortOrder
    price?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    _count?: ServicePricingRuleCountOrderByAggregateInput
    _avg?: ServicePricingRuleAvgOrderByAggregateInput
    _max?: ServicePricingRuleMaxOrderByAggregateInput
    _min?: ServicePricingRuleMinOrderByAggregateInput
    _sum?: ServicePricingRuleSumOrderByAggregateInput
  }

  export type ServicePricingRuleScalarWhereWithAggregatesInput = {
    AND?: ServicePricingRuleScalarWhereWithAggregatesInput | ServicePricingRuleScalarWhereWithAggregatesInput[]
    OR?: ServicePricingRuleScalarWhereWithAggregatesInput[]
    NOT?: ServicePricingRuleScalarWhereWithAggregatesInput | ServicePricingRuleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicePricingRule"> | string
    tenantId?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    serviceId?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    variantId?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    staffId?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    pricingType?: EnumPricingTypeWithAggregatesFilter<"ServicePricingRule"> | $Enums.PricingType
    dayOfWeek?: IntNullableWithAggregatesFilter<"ServicePricingRule"> | number | null
    startTime?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    endTime?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    seasonTag?: StringNullableWithAggregatesFilter<"ServicePricingRule"> | string | null
    price?: IntNullableWithAggregatesFilter<"ServicePricingRule"> | number | null
    priority?: IntNullableWithAggregatesFilter<"ServicePricingRule"> | number | null
    isActive?: BoolNullableWithAggregatesFilter<"ServicePricingRule"> | boolean | null
    createdAt?: DateTimeWithAggregatesFilter<"ServicePricingRule"> | Date | string
  }

  export type TenantCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutTenantInput
  }

  export type TenantUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutTenantInput
  }

  export type TenantUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutTenantNestedInput
  }

  export type TenantUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutTenantNestedInput
  }

  export type TenantCreateManyInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    userName?: string | null
    phonenumber?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    services?: ServiceCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    userName?: string | null
    phonenumber?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    services?: ServiceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    services?: ServiceUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    services?: ServiceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    userName?: string | null
    phonenumber?: string | null
    accessToken?: string | null
    refreshToken?: string | null
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerCreateInput = {
    id?: string
    storeName: string
    services?: ServiceCreateNestedManyWithoutSellerInput
  }

  export type SellerUncheckedCreateInput = {
    id?: string
    storeName: string
    services?: ServiceUncheckedCreateNestedManyWithoutSellerInput
  }

  export type SellerUpdateInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    services?: ServiceUpdateManyWithoutSellerNestedInput
  }

  export type SellerUncheckedUpdateInput = {
    storeName?: StringFieldUpdateOperationsInput | string
    services?: ServiceUncheckedUpdateManyWithoutSellerNestedInput
  }

  export type SellerCreateManyInput = {
    id?: string
    storeName: string
  }

  export type SellerUpdateManyMutationInput = {
    storeName?: StringFieldUpdateOperationsInput | string
  }

  export type SellerUncheckedUpdateManyInput = {
    storeName?: StringFieldUpdateOperationsInput | string
  }

  export type ServiceCreateInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    user?: UserCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    user?: UserUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceMediaCreateInput = {
    id?: string
    tenantId?: string | null
    url?: string | null
    alt?: string | null
    order?: number
    createdAt?: Date | string
    service?: ServiceCreateNestedOneWithoutMediasInput
  }

  export type ServiceMediaUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    serviceId?: string | null
    url?: string | null
    alt?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ServiceMediaUpdateInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutMediasNestedInput
  }

  export type ServiceMediaUncheckedUpdateInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceMediaCreateManyInput = {
    id?: string
    tenantId?: string | null
    serviceId?: string | null
    url?: string | null
    alt?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ServiceMediaUpdateManyMutationInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceMediaUncheckedUpdateManyInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceEvaluationCreateInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    evaluationContent?: string | null
    service?: ServiceCreateNestedOneWithoutEvaluationInput
  }

  export type ServiceEvaluationUncheckedCreateInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    userId?: string | null
    evaluationContent?: string | null
  }

  export type ServiceEvaluationUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
    service?: ServiceUpdateOneWithoutEvaluationNestedInput
  }

  export type ServiceEvaluationUncheckedUpdateInput = {
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceEvaluationCreateManyInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    userId?: string | null
    evaluationContent?: string | null
  }

  export type ServiceEvaluationUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceEvaluationUncheckedUpdateManyInput = {
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceRatingCreateInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    st?: number | null
    service?: ServiceCreateNestedOneWithoutRatingInput
  }

  export type ServiceRatingUncheckedCreateInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    userId?: string | null
    st?: number | null
  }

  export type ServiceRatingUpdateInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
    service?: ServiceUpdateOneWithoutRatingNestedInput
  }

  export type ServiceRatingUncheckedUpdateInput = {
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceRatingCreateManyInput = {
    id?: string
    serviceId?: string | null
    createdAt?: Date | string
    userId?: string | null
    st?: number | null
  }

  export type ServiceRatingUpdateManyMutationInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceRatingUncheckedUpdateManyInput = {
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServicePricingRuleCreateInput = {
    id?: string
    tenantId?: string | null
    variantId?: string | null
    staffId?: string | null
    pricingType: $Enums.PricingType
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    seasonTag?: string | null
    price?: number | null
    priority?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
    service?: ServiceCreateNestedOneWithoutPricingRulesInput
  }

  export type ServicePricingRuleUncheckedCreateInput = {
    id?: string
    tenantId?: string | null
    serviceId?: string | null
    variantId?: string | null
    staffId?: string | null
    pricingType: $Enums.PricingType
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    seasonTag?: string | null
    price?: number | null
    priority?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
  }

  export type ServicePricingRuleUpdateInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneWithoutPricingRulesNestedInput
  }

  export type ServicePricingRuleUncheckedUpdateInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingRuleCreateManyInput = {
    id?: string
    tenantId?: string | null
    serviceId?: string | null
    variantId?: string | null
    staffId?: string | null
    pricingType: $Enums.PricingType
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    seasonTag?: string | null
    price?: number | null
    priority?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
  }

  export type ServicePricingRuleUpdateManyMutationInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingRuleUncheckedUpdateManyInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TenantCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TenantMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    phonenumber?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    phonenumber?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    userName?: SortOrder
    phonenumber?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type SellerCountOrderByAggregateInput = {
    id?: SortOrder
    storeName?: SortOrder
  }

  export type SellerMaxOrderByAggregateInput = {
    id?: SortOrder
    storeName?: SortOrder
  }

  export type SellerMinOrderByAggregateInput = {
    id?: SortOrder
    storeName?: SortOrder
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPricingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingTypeNullableFilter<$PrismaModel> | $Enums.PricingType | null
    isSet?: boolean
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type TenantNullableScalarRelationFilter = {
    is?: TenantWhereInput | null
    isNot?: TenantWhereInput | null
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type SellerNullableScalarRelationFilter = {
    is?: SellerWhereInput | null
    isNot?: SellerWhereInput | null
  }

  export type ServicePricingRuleListRelationFilter = {
    every?: ServicePricingRuleWhereInput
    some?: ServicePricingRuleWhereInput
    none?: ServicePricingRuleWhereInput
  }

  export type ServiceMediaListRelationFilter = {
    every?: ServiceMediaWhereInput
    some?: ServiceMediaWhereInput
    none?: ServiceMediaWhereInput
  }

  export type ServiceEvaluationListRelationFilter = {
    every?: ServiceEvaluationWhereInput
    some?: ServiceEvaluationWhereInput
    none?: ServiceEvaluationWhereInput
  }

  export type ServiceRatingListRelationFilter = {
    every?: ServiceRatingWhereInput
    some?: ServiceRatingWhereInput
    none?: ServiceRatingWhereInput
  }

  export type ServicePricingRuleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceMediaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceEvaluationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceRatingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceTenantIdCodeCompoundUniqueInput = {
    tenantId: string
    code: string
  }

  export type ServiceTenantIdSlugCompoundUniqueInput = {
    tenantId: string
    slug: string
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    tags?: SortOrder
    pricingType?: SortOrder
    currency?: SortOrder
    displayPrice?: SortOrder
    taxIncluded?: SortOrder
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    isBookable?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    featured?: SortOrder
    badge?: SortOrder
    highlightColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    depositAmount?: SortOrder
    displayOrder?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    pricingType?: SortOrder
    currency?: SortOrder
    displayPrice?: SortOrder
    taxIncluded?: SortOrder
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    isBookable?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    featured?: SortOrder
    badge?: SortOrder
    highlightColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    userId?: SortOrder
    sellerId?: SortOrder
    code?: SortOrder
    title?: SortOrder
    description?: SortOrder
    slug?: SortOrder
    pricingType?: SortOrder
    currency?: SortOrder
    displayPrice?: SortOrder
    taxIncluded?: SortOrder
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    isBookable?: SortOrder
    requiresDeposit?: SortOrder
    depositAmount?: SortOrder
    featured?: SortOrder
    badge?: SortOrder
    highlightColor?: SortOrder
    displayOrder?: SortOrder
    isActive?: SortOrder
    metaTitle?: SortOrder
    metaDescription?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    taxRateBps?: SortOrder
    durationMin?: SortOrder
    bufferBeforeMin?: SortOrder
    bufferAfterMin?: SortOrder
    minStaffCount?: SortOrder
    maxStaffCount?: SortOrder
    depositAmount?: SortOrder
    displayOrder?: SortOrder
  }

  export type EnumPricingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PricingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ServiceMediaCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMediaAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type ServiceMediaMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMediaMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    url?: SortOrder
    alt?: SortOrder
    order?: SortOrder
    createdAt?: SortOrder
  }

  export type ServiceMediaSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type ServiceEvaluationCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    evaluationContent?: SortOrder
  }

  export type ServiceEvaluationMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    evaluationContent?: SortOrder
  }

  export type ServiceEvaluationMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    evaluationContent?: SortOrder
  }

  export type ServiceRatingCountOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    st?: SortOrder
  }

  export type ServiceRatingAvgOrderByAggregateInput = {
    st?: SortOrder
  }

  export type ServiceRatingMaxOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    st?: SortOrder
  }

  export type ServiceRatingMinOrderByAggregateInput = {
    id?: SortOrder
    serviceId?: SortOrder
    createdAt?: SortOrder
    userId?: SortOrder
    st?: SortOrder
  }

  export type ServiceRatingSumOrderByAggregateInput = {
    st?: SortOrder
  }

  export type EnumPricingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeFilter<$PrismaModel> | $Enums.PricingType
  }

  export type ServicePricingRuleCountOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    variantId?: SortOrder
    staffId?: SortOrder
    pricingType?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    seasonTag?: SortOrder
    price?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePricingRuleAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    price?: SortOrder
    priority?: SortOrder
  }

  export type ServicePricingRuleMaxOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    variantId?: SortOrder
    staffId?: SortOrder
    pricingType?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    seasonTag?: SortOrder
    price?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePricingRuleMinOrderByAggregateInput = {
    id?: SortOrder
    tenantId?: SortOrder
    serviceId?: SortOrder
    variantId?: SortOrder
    staffId?: SortOrder
    pricingType?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    seasonTag?: SortOrder
    price?: SortOrder
    priority?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
  }

  export type ServicePricingRuleSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    price?: SortOrder
    priority?: SortOrder
  }

  export type EnumPricingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PricingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeFilter<$PrismaModel>
  }

  export type ServiceCreateNestedManyWithoutTenantInput = {
    create?: XOR<ServiceCreateWithoutTenantInput, ServiceUncheckedCreateWithoutTenantInput> | ServiceCreateWithoutTenantInput[] | ServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutTenantInput | ServiceCreateOrConnectWithoutTenantInput[]
    createMany?: ServiceCreateManyTenantInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutTenantInput = {
    create?: XOR<ServiceCreateWithoutTenantInput, ServiceUncheckedCreateWithoutTenantInput> | ServiceCreateWithoutTenantInput[] | ServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutTenantInput | ServiceCreateOrConnectWithoutTenantInput[]
    createMany?: ServiceCreateManyTenantInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ServiceUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ServiceCreateWithoutTenantInput, ServiceUncheckedCreateWithoutTenantInput> | ServiceCreateWithoutTenantInput[] | ServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutTenantInput | ServiceCreateOrConnectWithoutTenantInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutTenantInput | ServiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ServiceCreateManyTenantInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutTenantInput | ServiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutTenantInput | ServiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutTenantNestedInput = {
    create?: XOR<ServiceCreateWithoutTenantInput, ServiceUncheckedCreateWithoutTenantInput> | ServiceCreateWithoutTenantInput[] | ServiceUncheckedCreateWithoutTenantInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutTenantInput | ServiceCreateOrConnectWithoutTenantInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutTenantInput | ServiceUpsertWithWhereUniqueWithoutTenantInput[]
    createMany?: ServiceCreateManyTenantInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutTenantInput | ServiceUpdateWithWhereUniqueWithoutTenantInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutTenantInput | ServiceUpdateManyWithWhereWithoutTenantInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type ServiceUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput> | ServiceCreateWithoutUserInput[] | ServiceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutUserInput | ServiceCreateOrConnectWithoutUserInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutUserInput | ServiceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: ServiceCreateManyUserInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutUserInput | ServiceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutUserInput | ServiceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCreateNestedManyWithoutSellerInput = {
    create?: XOR<ServiceCreateWithoutSellerInput, ServiceUncheckedCreateWithoutSellerInput> | ServiceCreateWithoutSellerInput[] | ServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSellerInput | ServiceCreateOrConnectWithoutSellerInput[]
    createMany?: ServiceCreateManySellerInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutSellerInput = {
    create?: XOR<ServiceCreateWithoutSellerInput, ServiceUncheckedCreateWithoutSellerInput> | ServiceCreateWithoutSellerInput[] | ServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSellerInput | ServiceCreateOrConnectWithoutSellerInput[]
    createMany?: ServiceCreateManySellerInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type ServiceUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ServiceCreateWithoutSellerInput, ServiceUncheckedCreateWithoutSellerInput> | ServiceCreateWithoutSellerInput[] | ServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSellerInput | ServiceCreateOrConnectWithoutSellerInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutSellerInput | ServiceUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ServiceCreateManySellerInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutSellerInput | ServiceUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutSellerInput | ServiceUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceUncheckedUpdateManyWithoutSellerNestedInput = {
    create?: XOR<ServiceCreateWithoutSellerInput, ServiceUncheckedCreateWithoutSellerInput> | ServiceCreateWithoutSellerInput[] | ServiceUncheckedCreateWithoutSellerInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutSellerInput | ServiceCreateOrConnectWithoutSellerInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutSellerInput | ServiceUpsertWithWhereUniqueWithoutSellerInput[]
    createMany?: ServiceCreateManySellerInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutSellerInput | ServiceUpdateWithWhereUniqueWithoutSellerInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutSellerInput | ServiceUpdateManyWithWhereWithoutSellerInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type ServiceCreatetagsInput = {
    set: string[]
  }

  export type TenantCreateNestedOneWithoutServicesInput = {
    create?: XOR<TenantCreateWithoutServicesInput, TenantUncheckedCreateWithoutServicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutServicesInput
    connect?: TenantWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutServicesInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    connect?: UserWhereUniqueInput
  }

  export type SellerCreateNestedOneWithoutServicesInput = {
    create?: XOR<SellerCreateWithoutServicesInput, SellerUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SellerCreateOrConnectWithoutServicesInput
    connect?: SellerWhereUniqueInput
  }

  export type ServicePricingRuleCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePricingRuleCreateWithoutServiceInput, ServicePricingRuleUncheckedCreateWithoutServiceInput> | ServicePricingRuleCreateWithoutServiceInput[] | ServicePricingRuleUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingRuleCreateOrConnectWithoutServiceInput | ServicePricingRuleCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePricingRuleCreateManyServiceInputEnvelope
    connect?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
  }

  export type ServiceMediaCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceMediaCreateWithoutServiceInput, ServiceMediaUncheckedCreateWithoutServiceInput> | ServiceMediaCreateWithoutServiceInput[] | ServiceMediaUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceMediaCreateOrConnectWithoutServiceInput | ServiceMediaCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceMediaCreateManyServiceInputEnvelope
    connect?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
  }

  export type ServiceEvaluationCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceEvaluationCreateWithoutServiceInput, ServiceEvaluationUncheckedCreateWithoutServiceInput> | ServiceEvaluationCreateWithoutServiceInput[] | ServiceEvaluationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceEvaluationCreateOrConnectWithoutServiceInput | ServiceEvaluationCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceEvaluationCreateManyServiceInputEnvelope
    connect?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
  }

  export type ServiceRatingCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePricingRuleCreateWithoutServiceInput, ServicePricingRuleUncheckedCreateWithoutServiceInput> | ServicePricingRuleCreateWithoutServiceInput[] | ServicePricingRuleUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingRuleCreateOrConnectWithoutServiceInput | ServicePricingRuleCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePricingRuleCreateManyServiceInputEnvelope
    connect?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
  }

  export type ServiceMediaUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceMediaCreateWithoutServiceInput, ServiceMediaUncheckedCreateWithoutServiceInput> | ServiceMediaCreateWithoutServiceInput[] | ServiceMediaUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceMediaCreateOrConnectWithoutServiceInput | ServiceMediaCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceMediaCreateManyServiceInputEnvelope
    connect?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
  }

  export type ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceEvaluationCreateWithoutServiceInput, ServiceEvaluationUncheckedCreateWithoutServiceInput> | ServiceEvaluationCreateWithoutServiceInput[] | ServiceEvaluationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceEvaluationCreateOrConnectWithoutServiceInput | ServiceEvaluationCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceEvaluationCreateManyServiceInputEnvelope
    connect?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
  }

  export type ServiceRatingUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
  }

  export type ServiceUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableEnumPricingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PricingType | null
    unset?: boolean
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
    unset?: boolean
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
    unset?: boolean
  }

  export type TenantUpdateOneWithoutServicesNestedInput = {
    create?: XOR<TenantCreateWithoutServicesInput, TenantUncheckedCreateWithoutServicesInput>
    connectOrCreate?: TenantCreateOrConnectWithoutServicesInput
    upsert?: TenantUpsertWithoutServicesInput
    disconnect?: boolean
    delete?: TenantWhereInput | boolean
    connect?: TenantWhereUniqueInput
    update?: XOR<XOR<TenantUpdateToOneWithWhereWithoutServicesInput, TenantUpdateWithoutServicesInput>, TenantUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateOneWithoutServicesNestedInput = {
    create?: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutServicesInput
    upsert?: UserUpsertWithoutServicesInput
    disconnect?: boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutServicesInput, UserUpdateWithoutServicesInput>, UserUncheckedUpdateWithoutServicesInput>
  }

  export type SellerUpdateOneWithoutServicesNestedInput = {
    create?: XOR<SellerCreateWithoutServicesInput, SellerUncheckedCreateWithoutServicesInput>
    connectOrCreate?: SellerCreateOrConnectWithoutServicesInput
    upsert?: SellerUpsertWithoutServicesInput
    disconnect?: boolean
    delete?: SellerWhereInput | boolean
    connect?: SellerWhereUniqueInput
    update?: XOR<XOR<SellerUpdateToOneWithWhereWithoutServicesInput, SellerUpdateWithoutServicesInput>, SellerUncheckedUpdateWithoutServicesInput>
  }

  export type ServicePricingRuleUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePricingRuleCreateWithoutServiceInput, ServicePricingRuleUncheckedCreateWithoutServiceInput> | ServicePricingRuleCreateWithoutServiceInput[] | ServicePricingRuleUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingRuleCreateOrConnectWithoutServiceInput | ServicePricingRuleCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePricingRuleUpsertWithWhereUniqueWithoutServiceInput | ServicePricingRuleUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePricingRuleCreateManyServiceInputEnvelope
    set?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    disconnect?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    delete?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    connect?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    update?: ServicePricingRuleUpdateWithWhereUniqueWithoutServiceInput | ServicePricingRuleUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePricingRuleUpdateManyWithWhereWithoutServiceInput | ServicePricingRuleUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePricingRuleScalarWhereInput | ServicePricingRuleScalarWhereInput[]
  }

  export type ServiceMediaUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceMediaCreateWithoutServiceInput, ServiceMediaUncheckedCreateWithoutServiceInput> | ServiceMediaCreateWithoutServiceInput[] | ServiceMediaUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceMediaCreateOrConnectWithoutServiceInput | ServiceMediaCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceMediaUpsertWithWhereUniqueWithoutServiceInput | ServiceMediaUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceMediaCreateManyServiceInputEnvelope
    set?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    disconnect?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    delete?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    connect?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    update?: ServiceMediaUpdateWithWhereUniqueWithoutServiceInput | ServiceMediaUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceMediaUpdateManyWithWhereWithoutServiceInput | ServiceMediaUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceMediaScalarWhereInput | ServiceMediaScalarWhereInput[]
  }

  export type ServiceEvaluationUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceEvaluationCreateWithoutServiceInput, ServiceEvaluationUncheckedCreateWithoutServiceInput> | ServiceEvaluationCreateWithoutServiceInput[] | ServiceEvaluationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceEvaluationCreateOrConnectWithoutServiceInput | ServiceEvaluationCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceEvaluationUpsertWithWhereUniqueWithoutServiceInput | ServiceEvaluationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceEvaluationCreateManyServiceInputEnvelope
    set?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    disconnect?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    delete?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    connect?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    update?: ServiceEvaluationUpdateWithWhereUniqueWithoutServiceInput | ServiceEvaluationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceEvaluationUpdateManyWithWhereWithoutServiceInput | ServiceEvaluationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceEvaluationScalarWhereInput | ServiceEvaluationScalarWhereInput[]
  }

  export type ServiceRatingUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutServiceInput | ServiceRatingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutServiceInput | ServiceRatingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutServiceInput | ServiceRatingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePricingRuleCreateWithoutServiceInput, ServicePricingRuleUncheckedCreateWithoutServiceInput> | ServicePricingRuleCreateWithoutServiceInput[] | ServicePricingRuleUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePricingRuleCreateOrConnectWithoutServiceInput | ServicePricingRuleCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePricingRuleUpsertWithWhereUniqueWithoutServiceInput | ServicePricingRuleUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePricingRuleCreateManyServiceInputEnvelope
    set?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    disconnect?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    delete?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    connect?: ServicePricingRuleWhereUniqueInput | ServicePricingRuleWhereUniqueInput[]
    update?: ServicePricingRuleUpdateWithWhereUniqueWithoutServiceInput | ServicePricingRuleUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePricingRuleUpdateManyWithWhereWithoutServiceInput | ServicePricingRuleUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePricingRuleScalarWhereInput | ServicePricingRuleScalarWhereInput[]
  }

  export type ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceMediaCreateWithoutServiceInput, ServiceMediaUncheckedCreateWithoutServiceInput> | ServiceMediaCreateWithoutServiceInput[] | ServiceMediaUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceMediaCreateOrConnectWithoutServiceInput | ServiceMediaCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceMediaUpsertWithWhereUniqueWithoutServiceInput | ServiceMediaUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceMediaCreateManyServiceInputEnvelope
    set?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    disconnect?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    delete?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    connect?: ServiceMediaWhereUniqueInput | ServiceMediaWhereUniqueInput[]
    update?: ServiceMediaUpdateWithWhereUniqueWithoutServiceInput | ServiceMediaUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceMediaUpdateManyWithWhereWithoutServiceInput | ServiceMediaUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceMediaScalarWhereInput | ServiceMediaScalarWhereInput[]
  }

  export type ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceEvaluationCreateWithoutServiceInput, ServiceEvaluationUncheckedCreateWithoutServiceInput> | ServiceEvaluationCreateWithoutServiceInput[] | ServiceEvaluationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceEvaluationCreateOrConnectWithoutServiceInput | ServiceEvaluationCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceEvaluationUpsertWithWhereUniqueWithoutServiceInput | ServiceEvaluationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceEvaluationCreateManyServiceInputEnvelope
    set?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    disconnect?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    delete?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    connect?: ServiceEvaluationWhereUniqueInput | ServiceEvaluationWhereUniqueInput[]
    update?: ServiceEvaluationUpdateWithWhereUniqueWithoutServiceInput | ServiceEvaluationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceEvaluationUpdateManyWithWhereWithoutServiceInput | ServiceEvaluationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceEvaluationScalarWhereInput | ServiceEvaluationScalarWhereInput[]
  }

  export type ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput> | ServiceRatingCreateWithoutServiceInput[] | ServiceRatingUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceRatingCreateOrConnectWithoutServiceInput | ServiceRatingCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceRatingUpsertWithWhereUniqueWithoutServiceInput | ServiceRatingUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceRatingCreateManyServiceInputEnvelope
    set?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    disconnect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    delete?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    connect?: ServiceRatingWhereUniqueInput | ServiceRatingWhereUniqueInput[]
    update?: ServiceRatingUpdateWithWhereUniqueWithoutServiceInput | ServiceRatingUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceRatingUpdateManyWithWhereWithoutServiceInput | ServiceRatingUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
  }

  export type ServiceCreateNestedOneWithoutMediasInput = {
    create?: XOR<ServiceCreateWithoutMediasInput, ServiceUncheckedCreateWithoutMediasInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutMediasInput
    connect?: ServiceWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUpdateOneWithoutMediasNestedInput = {
    create?: XOR<ServiceCreateWithoutMediasInput, ServiceUncheckedCreateWithoutMediasInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutMediasInput
    upsert?: ServiceUpsertWithoutMediasInput
    disconnect?: boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutMediasInput, ServiceUpdateWithoutMediasInput>, ServiceUncheckedUpdateWithoutMediasInput>
  }

  export type ServiceCreateNestedOneWithoutEvaluationInput = {
    create?: XOR<ServiceCreateWithoutEvaluationInput, ServiceUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEvaluationInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneWithoutEvaluationNestedInput = {
    create?: XOR<ServiceCreateWithoutEvaluationInput, ServiceUncheckedCreateWithoutEvaluationInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutEvaluationInput
    upsert?: ServiceUpsertWithoutEvaluationInput
    disconnect?: boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutEvaluationInput, ServiceUpdateWithoutEvaluationInput>, ServiceUncheckedUpdateWithoutEvaluationInput>
  }

  export type ServiceCreateNestedOneWithoutRatingInput = {
    create?: XOR<ServiceCreateWithoutRatingInput, ServiceUncheckedCreateWithoutRatingInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutRatingInput
    connect?: ServiceWhereUniqueInput
  }

  export type ServiceUpdateOneWithoutRatingNestedInput = {
    create?: XOR<ServiceCreateWithoutRatingInput, ServiceUncheckedCreateWithoutRatingInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutRatingInput
    upsert?: ServiceUpsertWithoutRatingInput
    disconnect?: boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutRatingInput, ServiceUpdateWithoutRatingInput>, ServiceUncheckedUpdateWithoutRatingInput>
  }

  export type ServiceCreateNestedOneWithoutPricingRulesInput = {
    create?: XOR<ServiceCreateWithoutPricingRulesInput, ServiceUncheckedCreateWithoutPricingRulesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPricingRulesInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumPricingTypeFieldUpdateOperationsInput = {
    set?: $Enums.PricingType
  }

  export type ServiceUpdateOneWithoutPricingRulesNestedInput = {
    create?: XOR<ServiceCreateWithoutPricingRulesInput, ServiceUncheckedCreateWithoutPricingRulesInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutPricingRulesInput
    upsert?: ServiceUpsertWithoutPricingRulesInput
    disconnect?: boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutPricingRulesInput, ServiceUpdateWithoutPricingRulesInput>, ServiceUncheckedUpdateWithoutPricingRulesInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedEnumPricingTypeNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingTypeNullableFilter<$PrismaModel> | $Enums.PricingType | null
    isSet?: boolean
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
    isSet?: boolean
  }

  export type NestedEnumPricingTypeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel> | null
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel> | null
    not?: NestedEnumPricingTypeNullableWithAggregatesFilter<$PrismaModel> | $Enums.PricingType | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeNullableFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumPricingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeFilter<$PrismaModel> | $Enums.PricingType
  }

  export type NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PricingType | EnumPricingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PricingType[] | ListEnumPricingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPricingTypeWithAggregatesFilter<$PrismaModel> | $Enums.PricingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPricingTypeFilter<$PrismaModel>
    _max?: NestedEnumPricingTypeFilter<$PrismaModel>
  }

  export type ServiceCreateWithoutTenantInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutTenantInput = {
    id?: string
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutTenantInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutTenantInput, ServiceUncheckedCreateWithoutTenantInput>
  }

  export type ServiceCreateManyTenantInputEnvelope = {
    data: ServiceCreateManyTenantInput | ServiceCreateManyTenantInput[]
  }

  export type ServiceUpsertWithWhereUniqueWithoutTenantInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutTenantInput, ServiceUncheckedUpdateWithoutTenantInput>
    create: XOR<ServiceCreateWithoutTenantInput, ServiceUncheckedCreateWithoutTenantInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutTenantInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutTenantInput, ServiceUncheckedUpdateWithoutTenantInput>
  }

  export type ServiceUpdateManyWithWhereWithoutTenantInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutTenantInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    tenantId?: StringNullableFilter<"Service"> | string | null
    userId?: StringNullableFilter<"Service"> | string | null
    sellerId?: StringNullableFilter<"Service"> | string | null
    code?: StringNullableFilter<"Service"> | string | null
    title?: StringNullableFilter<"Service"> | string | null
    description?: StringNullableFilter<"Service"> | string | null
    slug?: StringNullableFilter<"Service"> | string | null
    tags?: StringNullableListFilter<"Service">
    pricingType?: EnumPricingTypeNullableFilter<"Service"> | $Enums.PricingType | null
    currency?: StringNullableFilter<"Service"> | string | null
    displayPrice?: BoolNullableFilter<"Service"> | boolean | null
    taxIncluded?: BoolNullableFilter<"Service"> | boolean | null
    taxRateBps?: IntNullableFilter<"Service"> | number | null
    durationMin?: IntNullableFilter<"Service"> | number | null
    bufferBeforeMin?: IntNullableFilter<"Service"> | number | null
    bufferAfterMin?: IntNullableFilter<"Service"> | number | null
    minStaffCount?: IntNullableFilter<"Service"> | number | null
    maxStaffCount?: IntNullableFilter<"Service"> | number | null
    isBookable?: BoolNullableFilter<"Service"> | boolean | null
    requiresDeposit?: BoolNullableFilter<"Service"> | boolean | null
    depositAmount?: IntNullableFilter<"Service"> | number | null
    featured?: BoolNullableFilter<"Service"> | boolean | null
    badge?: StringNullableFilter<"Service"> | string | null
    highlightColor?: StringNullableFilter<"Service"> | string | null
    displayOrder?: IntNullableFilter<"Service"> | number | null
    isActive?: BoolNullableFilter<"Service"> | boolean | null
    metaTitle?: StringNullableFilter<"Service"> | string | null
    metaDescription?: StringNullableFilter<"Service"> | string | null
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type ServiceCreateWithoutUserInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutUserInput = {
    id?: string
    tenantId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutUserInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceCreateManyUserInputEnvelope = {
    data: ServiceCreateManyUserInput | ServiceCreateManyUserInput[]
  }

  export type ServiceUpsertWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
    create: XOR<ServiceCreateWithoutUserInput, ServiceUncheckedCreateWithoutUserInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutUserInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutUserInput, ServiceUncheckedUpdateWithoutUserInput>
  }

  export type ServiceUpdateManyWithWhereWithoutUserInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutUserInput>
  }

  export type ServiceCreateWithoutSellerInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    user?: UserCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutSellerInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutSellerInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutSellerInput, ServiceUncheckedCreateWithoutSellerInput>
  }

  export type ServiceCreateManySellerInputEnvelope = {
    data: ServiceCreateManySellerInput | ServiceCreateManySellerInput[]
  }

  export type ServiceUpsertWithWhereUniqueWithoutSellerInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutSellerInput, ServiceUncheckedUpdateWithoutSellerInput>
    create: XOR<ServiceCreateWithoutSellerInput, ServiceUncheckedCreateWithoutSellerInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutSellerInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutSellerInput, ServiceUncheckedUpdateWithoutSellerInput>
  }

  export type ServiceUpdateManyWithWhereWithoutSellerInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutSellerInput>
  }

  export type TenantCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantUncheckedCreateWithoutServicesInput = {
    id?: string
    name: string
    slug: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TenantCreateOrConnectWithoutServicesInput = {
    where: TenantWhereUniqueInput
    create: XOR<TenantCreateWithoutServicesInput, TenantUncheckedCreateWithoutServicesInput>
  }

  export type UserCreateWithoutServicesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    userName?: string | null
    phonenumber?: string | null
    accessToken?: string | null
    refreshToken?: string | null
  }

  export type UserUncheckedCreateWithoutServicesInput = {
    id?: string
    email: string
    password: string
    name?: string | null
    userName?: string | null
    phonenumber?: string | null
    accessToken?: string | null
    refreshToken?: string | null
  }

  export type UserCreateOrConnectWithoutServicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
  }

  export type SellerCreateWithoutServicesInput = {
    id?: string
    storeName: string
  }

  export type SellerUncheckedCreateWithoutServicesInput = {
    id?: string
    storeName: string
  }

  export type SellerCreateOrConnectWithoutServicesInput = {
    where: SellerWhereUniqueInput
    create: XOR<SellerCreateWithoutServicesInput, SellerUncheckedCreateWithoutServicesInput>
  }

  export type ServicePricingRuleCreateWithoutServiceInput = {
    id?: string
    tenantId?: string | null
    variantId?: string | null
    staffId?: string | null
    pricingType: $Enums.PricingType
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    seasonTag?: string | null
    price?: number | null
    priority?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
  }

  export type ServicePricingRuleUncheckedCreateWithoutServiceInput = {
    id?: string
    tenantId?: string | null
    variantId?: string | null
    staffId?: string | null
    pricingType: $Enums.PricingType
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    seasonTag?: string | null
    price?: number | null
    priority?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
  }

  export type ServicePricingRuleCreateOrConnectWithoutServiceInput = {
    where: ServicePricingRuleWhereUniqueInput
    create: XOR<ServicePricingRuleCreateWithoutServiceInput, ServicePricingRuleUncheckedCreateWithoutServiceInput>
  }

  export type ServicePricingRuleCreateManyServiceInputEnvelope = {
    data: ServicePricingRuleCreateManyServiceInput | ServicePricingRuleCreateManyServiceInput[]
  }

  export type ServiceMediaCreateWithoutServiceInput = {
    id?: string
    tenantId?: string | null
    url?: string | null
    alt?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ServiceMediaUncheckedCreateWithoutServiceInput = {
    id?: string
    tenantId?: string | null
    url?: string | null
    alt?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ServiceMediaCreateOrConnectWithoutServiceInput = {
    where: ServiceMediaWhereUniqueInput
    create: XOR<ServiceMediaCreateWithoutServiceInput, ServiceMediaUncheckedCreateWithoutServiceInput>
  }

  export type ServiceMediaCreateManyServiceInputEnvelope = {
    data: ServiceMediaCreateManyServiceInput | ServiceMediaCreateManyServiceInput[]
  }

  export type ServiceEvaluationCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    evaluationContent?: string | null
  }

  export type ServiceEvaluationUncheckedCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    evaluationContent?: string | null
  }

  export type ServiceEvaluationCreateOrConnectWithoutServiceInput = {
    where: ServiceEvaluationWhereUniqueInput
    create: XOR<ServiceEvaluationCreateWithoutServiceInput, ServiceEvaluationUncheckedCreateWithoutServiceInput>
  }

  export type ServiceEvaluationCreateManyServiceInputEnvelope = {
    data: ServiceEvaluationCreateManyServiceInput | ServiceEvaluationCreateManyServiceInput[]
  }

  export type ServiceRatingCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    st?: number | null
  }

  export type ServiceRatingUncheckedCreateWithoutServiceInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    st?: number | null
  }

  export type ServiceRatingCreateOrConnectWithoutServiceInput = {
    where: ServiceRatingWhereUniqueInput
    create: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceRatingCreateManyServiceInputEnvelope = {
    data: ServiceRatingCreateManyServiceInput | ServiceRatingCreateManyServiceInput[]
  }

  export type TenantUpsertWithoutServicesInput = {
    update: XOR<TenantUpdateWithoutServicesInput, TenantUncheckedUpdateWithoutServicesInput>
    create: XOR<TenantCreateWithoutServicesInput, TenantUncheckedCreateWithoutServicesInput>
    where?: TenantWhereInput
  }

  export type TenantUpdateToOneWithWhereWithoutServicesInput = {
    where?: TenantWhereInput
    data: XOR<TenantUpdateWithoutServicesInput, TenantUncheckedUpdateWithoutServicesInput>
  }

  export type TenantUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TenantUncheckedUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutServicesInput = {
    update: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
    create: XOR<UserCreateWithoutServicesInput, UserUncheckedCreateWithoutServicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutServicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutServicesInput, UserUncheckedUpdateWithoutServicesInput>
  }

  export type UserUpdateWithoutServicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserUncheckedUpdateWithoutServicesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    userName?: NullableStringFieldUpdateOperationsInput | string | null
    phonenumber?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SellerUpsertWithoutServicesInput = {
    update: XOR<SellerUpdateWithoutServicesInput, SellerUncheckedUpdateWithoutServicesInput>
    create: XOR<SellerCreateWithoutServicesInput, SellerUncheckedCreateWithoutServicesInput>
    where?: SellerWhereInput
  }

  export type SellerUpdateToOneWithWhereWithoutServicesInput = {
    where?: SellerWhereInput
    data: XOR<SellerUpdateWithoutServicesInput, SellerUncheckedUpdateWithoutServicesInput>
  }

  export type SellerUpdateWithoutServicesInput = {
    storeName?: StringFieldUpdateOperationsInput | string
  }

  export type SellerUncheckedUpdateWithoutServicesInput = {
    storeName?: StringFieldUpdateOperationsInput | string
  }

  export type ServicePricingRuleUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServicePricingRuleWhereUniqueInput
    update: XOR<ServicePricingRuleUpdateWithoutServiceInput, ServicePricingRuleUncheckedUpdateWithoutServiceInput>
    create: XOR<ServicePricingRuleCreateWithoutServiceInput, ServicePricingRuleUncheckedCreateWithoutServiceInput>
  }

  export type ServicePricingRuleUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServicePricingRuleWhereUniqueInput
    data: XOR<ServicePricingRuleUpdateWithoutServiceInput, ServicePricingRuleUncheckedUpdateWithoutServiceInput>
  }

  export type ServicePricingRuleUpdateManyWithWhereWithoutServiceInput = {
    where: ServicePricingRuleScalarWhereInput
    data: XOR<ServicePricingRuleUpdateManyMutationInput, ServicePricingRuleUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServicePricingRuleScalarWhereInput = {
    AND?: ServicePricingRuleScalarWhereInput | ServicePricingRuleScalarWhereInput[]
    OR?: ServicePricingRuleScalarWhereInput[]
    NOT?: ServicePricingRuleScalarWhereInput | ServicePricingRuleScalarWhereInput[]
    id?: StringFilter<"ServicePricingRule"> | string
    tenantId?: StringNullableFilter<"ServicePricingRule"> | string | null
    serviceId?: StringNullableFilter<"ServicePricingRule"> | string | null
    variantId?: StringNullableFilter<"ServicePricingRule"> | string | null
    staffId?: StringNullableFilter<"ServicePricingRule"> | string | null
    pricingType?: EnumPricingTypeFilter<"ServicePricingRule"> | $Enums.PricingType
    dayOfWeek?: IntNullableFilter<"ServicePricingRule"> | number | null
    startTime?: StringNullableFilter<"ServicePricingRule"> | string | null
    endTime?: StringNullableFilter<"ServicePricingRule"> | string | null
    seasonTag?: StringNullableFilter<"ServicePricingRule"> | string | null
    price?: IntNullableFilter<"ServicePricingRule"> | number | null
    priority?: IntNullableFilter<"ServicePricingRule"> | number | null
    isActive?: BoolNullableFilter<"ServicePricingRule"> | boolean | null
    createdAt?: DateTimeFilter<"ServicePricingRule"> | Date | string
  }

  export type ServiceMediaUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceMediaWhereUniqueInput
    update: XOR<ServiceMediaUpdateWithoutServiceInput, ServiceMediaUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceMediaCreateWithoutServiceInput, ServiceMediaUncheckedCreateWithoutServiceInput>
  }

  export type ServiceMediaUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceMediaWhereUniqueInput
    data: XOR<ServiceMediaUpdateWithoutServiceInput, ServiceMediaUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceMediaUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceMediaScalarWhereInput
    data: XOR<ServiceMediaUpdateManyMutationInput, ServiceMediaUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceMediaScalarWhereInput = {
    AND?: ServiceMediaScalarWhereInput | ServiceMediaScalarWhereInput[]
    OR?: ServiceMediaScalarWhereInput[]
    NOT?: ServiceMediaScalarWhereInput | ServiceMediaScalarWhereInput[]
    id?: StringFilter<"ServiceMedia"> | string
    tenantId?: StringNullableFilter<"ServiceMedia"> | string | null
    serviceId?: StringNullableFilter<"ServiceMedia"> | string | null
    url?: StringNullableFilter<"ServiceMedia"> | string | null
    alt?: StringNullableFilter<"ServiceMedia"> | string | null
    order?: IntFilter<"ServiceMedia"> | number
    createdAt?: DateTimeFilter<"ServiceMedia"> | Date | string
  }

  export type ServiceEvaluationUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceEvaluationWhereUniqueInput
    update: XOR<ServiceEvaluationUpdateWithoutServiceInput, ServiceEvaluationUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceEvaluationCreateWithoutServiceInput, ServiceEvaluationUncheckedCreateWithoutServiceInput>
  }

  export type ServiceEvaluationUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceEvaluationWhereUniqueInput
    data: XOR<ServiceEvaluationUpdateWithoutServiceInput, ServiceEvaluationUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceEvaluationUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceEvaluationScalarWhereInput
    data: XOR<ServiceEvaluationUpdateManyMutationInput, ServiceEvaluationUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceEvaluationScalarWhereInput = {
    AND?: ServiceEvaluationScalarWhereInput | ServiceEvaluationScalarWhereInput[]
    OR?: ServiceEvaluationScalarWhereInput[]
    NOT?: ServiceEvaluationScalarWhereInput | ServiceEvaluationScalarWhereInput[]
    id?: StringFilter<"ServiceEvaluation"> | string
    serviceId?: StringNullableFilter<"ServiceEvaluation"> | string | null
    createdAt?: DateTimeFilter<"ServiceEvaluation"> | Date | string
    userId?: StringNullableFilter<"ServiceEvaluation"> | string | null
    evaluationContent?: StringNullableFilter<"ServiceEvaluation"> | string | null
  }

  export type ServiceRatingUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceRatingWhereUniqueInput
    update: XOR<ServiceRatingUpdateWithoutServiceInput, ServiceRatingUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceRatingCreateWithoutServiceInput, ServiceRatingUncheckedCreateWithoutServiceInput>
  }

  export type ServiceRatingUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceRatingWhereUniqueInput
    data: XOR<ServiceRatingUpdateWithoutServiceInput, ServiceRatingUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceRatingUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceRatingScalarWhereInput
    data: XOR<ServiceRatingUpdateManyMutationInput, ServiceRatingUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceRatingScalarWhereInput = {
    AND?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
    OR?: ServiceRatingScalarWhereInput[]
    NOT?: ServiceRatingScalarWhereInput | ServiceRatingScalarWhereInput[]
    id?: StringFilter<"ServiceRating"> | string
    serviceId?: StringNullableFilter<"ServiceRating"> | string | null
    createdAt?: DateTimeFilter<"ServiceRating"> | Date | string
    userId?: StringNullableFilter<"ServiceRating"> | string | null
    st?: IntNullableFilter<"ServiceRating"> | number | null
  }

  export type ServiceCreateWithoutMediasInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    user?: UserCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutMediasInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutMediasInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutMediasInput, ServiceUncheckedCreateWithoutMediasInput>
  }

  export type ServiceUpsertWithoutMediasInput = {
    update: XOR<ServiceUpdateWithoutMediasInput, ServiceUncheckedUpdateWithoutMediasInput>
    create: XOR<ServiceCreateWithoutMediasInput, ServiceUncheckedCreateWithoutMediasInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutMediasInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutMediasInput, ServiceUncheckedUpdateWithoutMediasInput>
  }

  export type ServiceUpdateWithoutMediasInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    user?: UserUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutMediasInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutEvaluationInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    user?: UserCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutEvaluationInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutEvaluationInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutEvaluationInput, ServiceUncheckedCreateWithoutEvaluationInput>
  }

  export type ServiceUpsertWithoutEvaluationInput = {
    update: XOR<ServiceUpdateWithoutEvaluationInput, ServiceUncheckedUpdateWithoutEvaluationInput>
    create: XOR<ServiceCreateWithoutEvaluationInput, ServiceUncheckedCreateWithoutEvaluationInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutEvaluationInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutEvaluationInput, ServiceUncheckedUpdateWithoutEvaluationInput>
  }

  export type ServiceUpdateWithoutEvaluationInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    user?: UserUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutEvaluationInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutRatingInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    user?: UserCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    pricingRules?: ServicePricingRuleCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutRatingInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    pricingRules?: ServicePricingRuleUncheckedCreateNestedManyWithoutServiceInput
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutRatingInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutRatingInput, ServiceUncheckedCreateWithoutRatingInput>
  }

  export type ServiceUpsertWithoutRatingInput = {
    update: XOR<ServiceUpdateWithoutRatingInput, ServiceUncheckedUpdateWithoutRatingInput>
    create: XOR<ServiceCreateWithoutRatingInput, ServiceUncheckedCreateWithoutRatingInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutRatingInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutRatingInput, ServiceUncheckedUpdateWithoutRatingInput>
  }

  export type ServiceUpdateWithoutRatingInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    user?: UserUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutRatingInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateWithoutPricingRulesInput = {
    id?: string
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tenant?: TenantCreateNestedOneWithoutServicesInput
    user?: UserCreateNestedOneWithoutServicesInput
    seller?: SellerCreateNestedOneWithoutServicesInput
    medias?: ServiceMediaCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutPricingRulesInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    medias?: ServiceMediaUncheckedCreateNestedManyWithoutServiceInput
    evaluation?: ServiceEvaluationUncheckedCreateNestedManyWithoutServiceInput
    rating?: ServiceRatingUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutPricingRulesInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutPricingRulesInput, ServiceUncheckedCreateWithoutPricingRulesInput>
  }

  export type ServiceUpsertWithoutPricingRulesInput = {
    update: XOR<ServiceUpdateWithoutPricingRulesInput, ServiceUncheckedUpdateWithoutPricingRulesInput>
    create: XOR<ServiceCreateWithoutPricingRulesInput, ServiceUncheckedCreateWithoutPricingRulesInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutPricingRulesInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutPricingRulesInput, ServiceUncheckedUpdateWithoutPricingRulesInput>
  }

  export type ServiceUpdateWithoutPricingRulesInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    user?: UserUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutPricingRulesInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyTenantInput = {
    id?: string
    userId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutTenantInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutTenantInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutTenantInput = {
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManyUserInput = {
    id?: string
    tenantId?: string | null
    sellerId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutUserInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    seller?: SellerUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutUserInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutUserInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    sellerId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateManySellerInput = {
    id?: string
    tenantId?: string | null
    userId?: string | null
    code?: string | null
    title?: string | null
    description?: string | null
    slug?: string | null
    tags?: ServiceCreatetagsInput | string[]
    pricingType?: $Enums.PricingType | null
    currency?: string | null
    displayPrice?: boolean | null
    taxIncluded?: boolean | null
    taxRateBps?: number | null
    durationMin?: number | null
    bufferBeforeMin?: number | null
    bufferAfterMin?: number | null
    minStaffCount?: number | null
    maxStaffCount?: number | null
    isBookable?: boolean | null
    requiresDeposit?: boolean | null
    depositAmount?: number | null
    featured?: boolean | null
    badge?: string | null
    highlightColor?: string | null
    displayOrder?: number | null
    isActive?: boolean | null
    metaTitle?: string | null
    metaDescription?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutSellerInput = {
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tenant?: TenantUpdateOneWithoutServicesNestedInput
    user?: UserUpdateOneWithoutServicesNestedInput
    pricingRules?: ServicePricingRuleUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutSellerInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    pricingRules?: ServicePricingRuleUncheckedUpdateManyWithoutServiceNestedInput
    medias?: ServiceMediaUncheckedUpdateManyWithoutServiceNestedInput
    evaluation?: ServiceEvaluationUncheckedUpdateManyWithoutServiceNestedInput
    rating?: ServiceRatingUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutSellerInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    code?: NullableStringFieldUpdateOperationsInput | string | null
    title?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: ServiceUpdatetagsInput | string[]
    pricingType?: NullableEnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType | null
    currency?: NullableStringFieldUpdateOperationsInput | string | null
    displayPrice?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxIncluded?: NullableBoolFieldUpdateOperationsInput | boolean | null
    taxRateBps?: NullableIntFieldUpdateOperationsInput | number | null
    durationMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferBeforeMin?: NullableIntFieldUpdateOperationsInput | number | null
    bufferAfterMin?: NullableIntFieldUpdateOperationsInput | number | null
    minStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    maxStaffCount?: NullableIntFieldUpdateOperationsInput | number | null
    isBookable?: NullableBoolFieldUpdateOperationsInput | boolean | null
    requiresDeposit?: NullableBoolFieldUpdateOperationsInput | boolean | null
    depositAmount?: NullableIntFieldUpdateOperationsInput | number | null
    featured?: NullableBoolFieldUpdateOperationsInput | boolean | null
    badge?: NullableStringFieldUpdateOperationsInput | string | null
    highlightColor?: NullableStringFieldUpdateOperationsInput | string | null
    displayOrder?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    metaTitle?: NullableStringFieldUpdateOperationsInput | string | null
    metaDescription?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingRuleCreateManyServiceInput = {
    id?: string
    tenantId?: string | null
    variantId?: string | null
    staffId?: string | null
    pricingType: $Enums.PricingType
    dayOfWeek?: number | null
    startTime?: string | null
    endTime?: string | null
    seasonTag?: string | null
    price?: number | null
    priority?: number | null
    isActive?: boolean | null
    createdAt?: Date | string
  }

  export type ServiceMediaCreateManyServiceInput = {
    id?: string
    tenantId?: string | null
    url?: string | null
    alt?: string | null
    order?: number
    createdAt?: Date | string
  }

  export type ServiceEvaluationCreateManyServiceInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    evaluationContent?: string | null
  }

  export type ServiceRatingCreateManyServiceInput = {
    id?: string
    createdAt?: Date | string
    userId?: string | null
    st?: number | null
  }

  export type ServicePricingRuleUpdateWithoutServiceInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingRuleUncheckedUpdateWithoutServiceInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePricingRuleUncheckedUpdateManyWithoutServiceInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    variantId?: NullableStringFieldUpdateOperationsInput | string | null
    staffId?: NullableStringFieldUpdateOperationsInput | string | null
    pricingType?: EnumPricingTypeFieldUpdateOperationsInput | $Enums.PricingType
    dayOfWeek?: NullableIntFieldUpdateOperationsInput | number | null
    startTime?: NullableStringFieldUpdateOperationsInput | string | null
    endTime?: NullableStringFieldUpdateOperationsInput | string | null
    seasonTag?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableIntFieldUpdateOperationsInput | number | null
    priority?: NullableIntFieldUpdateOperationsInput | number | null
    isActive?: NullableBoolFieldUpdateOperationsInput | boolean | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceMediaUpdateWithoutServiceInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceMediaUncheckedUpdateWithoutServiceInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceMediaUncheckedUpdateManyWithoutServiceInput = {
    tenantId?: NullableStringFieldUpdateOperationsInput | string | null
    url?: NullableStringFieldUpdateOperationsInput | string | null
    alt?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceEvaluationUpdateWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceEvaluationUncheckedUpdateWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceEvaluationUncheckedUpdateManyWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    evaluationContent?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ServiceRatingUpdateWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceRatingUncheckedUpdateWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ServiceRatingUncheckedUpdateManyWithoutServiceInput = {
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    st?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}